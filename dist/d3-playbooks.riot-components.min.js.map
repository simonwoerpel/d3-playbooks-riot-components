{"version":3,"sources":["webpack:///d3-playbooks.riot-components.min.js","webpack:///webpack/bootstrap 41605ce484907994cc6c","webpack:///./~/riot/riot.js","webpack:///./~/string-template/index.js","webpack:///./src/components/raw_html.tag","webpack:///./src/utils/hilight/hilight_node.js","webpack:///./src/components/infobox.tag","webpack:///./src/components/legend.tag","webpack:///./src/components/selector.tag","webpack:///./src/examples.js","webpack:///./src/main.js","webpack:///./src/playbooks/defaults.js","webpack:///./src/playbooks/plays.js","webpack:///./src/playbooks/template.js","webpack:///./src/public.js","webpack:///./src/utils/events/add_mouse_events.js","webpack:///./src/utils/events/event_names.js","webpack:///./src/utils/events/init_riot_events.js","webpack:///./src/utils/hilight/find_selection.js","webpack:///./src/utils/hilight/hilight_selection.js","webpack:///./src/utils/hilight/unhilight_node.js","webpack:///./src/utils/hilight/unhilight_selection.js","webpack:///./src/utils/infobox/get_infobox_template.js","webpack:///./src/utils/legend/get_legend_items.js","webpack:///./src/utils/legend/get_legend_template.js","webpack:///./src/utils/mount_riot_tag.js","webpack:///./src/utils/selector/get_selector_data.js","webpack:///./src/styles/main.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/immutable/dist/immutable.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/styles/main.scss?dd28"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","riot","global","factory","this","isSVGTag","name","RE_SVG_TAGS","test","isBoolAttr","value","RE_BOOL_ATTRS","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","obj","key","descriptor","Object","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","mkEl","isSvg","createElementNS","createElement","getOuterHTML","el","outerHTML","container","appendChild","cloneNode","innerHTML","setInnerHTML","html","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","remAttr","dom","removeAttribute","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","length","i","contains","array","item","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","slice","defineProperty","options","extend","enumerable","configurable","src","args","arguments","handleEvent","handler","e","ptag","_parent","_item","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","addEventListener","EVENTS_PREFIX_REGEX","_riotEvents","removeEventListener","updateDataIs","expr","parent","conf","tagName","tmpl","attrs","a","unmount","impl","__TAG_IMPL","hasImpl","initChildTag","mount","on","delName","opts","dataIs","tags","_tags","arrayishRemove","updateExpression","old","attrName","attr","isToggle","SHOW_DIRECTIVE","HIDE_DIRECTIVE","isValueAttr","isVirtual","bool","_riot_id","frag","makeVirtual","parentElement","replaceChild","isRtag","IE_VERSION","nodeValue","isAttrRemoved","style","display","ATTRS_PREFIX","IS_DIRECTIVE","CASE_SENSITIVE_ATTRIBUTES","updateAllExpressions","expressions","mkitem","base","create","pos","unmountRedundant","items","t","j","splice","moveNestedTags","this$1","keys","moveChildTag","apply","move","nextTag","moveVirtual","insert","append","_each","LOOP_DIRECTIVE","hasKeys","mustReorder","LOOP_NO_REORDER_DIRECTIVE","getTagName","useRoot","RE_SPECIAL_TAGS","ref","child","getTag","ifExpr","CONDITIONAL_DIRECTIVE","oldItems","isLoop","isAnonymous","loopKeys","removeChild","isObject$$1","map","filter","doReorder","oldPos","isNew","mustAppend","Tag$1","arrayishAdd","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","push","IfExpr","init","attributes","parseAttributes","REF_DIRECTIVES","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","checkSvg","match","GENERIC","tblTags","stub","Tag$2","css","onCreate","tag$1","class","constructor","mountTo","styleManager","inject","add","tag2$1","exists","util","hotReloader","mount$1","pushTagsTo","riotTag","tag$$1","elem","allTags","selectTags","split","nodeList","_el","mixin$1","mix","g","_id","store","globals","mixins","Error","prototype","update$1","__TAGS_CACHE","unregister$1","updateOpts","instAttrs","cleanUpData","implAttrs","propsInSyncWithParent","observable$1","_tag","virts","tail","head","__uid","data","shouldUpdate","inheritFrom","trigger","instance","props","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","get","set","hasOwnProperty","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","_internal","unmountAll","off","mustSync","newPos","skipDataIs","namedTag","o","ensureArray","dest","isArr","isInStub","inStub","implClass","_innerHTML","sib","reduce","styleNode","cssTextProp","WIN","window","undefined","RE_SPECIAL_TAGS_NO_OPTION","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","getElementsByTagName","styleSheet","join","cssText","brackets","UNDEF","_loopback","re","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","s","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","start","index","settings","_tmpl","_logErr","err","riotData","errorHandler","console","error","_getTmpl","Function","qstr","RE_DQUOTE","_parseExpr","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","String","fromCharCode","version","callbacks","defineProperties","event","fns","arguments$1","arglen","misc","pristine","newValue","current","attrValue","rawValue","hasExp","firstRun","customParent","tagOrDom","refs","tr","th","td","col","vdom","Tag$$1","tag2$$1","mount$$1","mixin$$1","update$$1","unregister$$1","observable","riot$1","Tag","tag2","unregister","template","string","nargs","result","_this","updateContent","content","default","classList","_interopRequireDefault","__esModule","_stringTemplate","_stringTemplate2","empty","control","EVT","updateInfobox","rawContent","emptyInfobox","templates","wrapper","body","legendItems","l","active","labels","hilight","label","updateSelector","getLabel","d3","playbooks","barChart","elementId","render","legend","wrapperTemplate","itemTemplate","infobox","element","d","x","y","sortItems","scatterChart","color","schemeCategory10","getLegendItems","C","getColor","multiLineChart","dataUrl","yCols","_examples","_hilight_node","_hilight_node2","_unhilight_node","_unhilight_node2","hilightNode","unhilightNode","_mount_riot_tag","_mount_riot_tag2","_get_legend_items","_get_legend_items2","_get_legend_template","_get_legend_template2","_get_infobox_template","_get_infobox_template2","_get_selector_data","_get_selector_data2","_find_selection","_find_selection2","_hilight_selection","_hilight_selection2","_unhilight_selection","_unhilight_selection2","_add_mouse_events","_add_mouse_events2","_init_riot_events","_init_riot_events2","getControl","addMouseEvents","initRiotEvents","getLegendTemplates","mountLegend","riotSelector","cssClass","legendTemplates","getInfoboxTemplate","mountInfobox","infoboxTemplate","getSelectorData","mountSelector","xCol","selectorData","findSelectionForHilight","hilightSelection","unhilightSelection","_events","draw","legendEl","infoboxEl","selectorEl","_unhilight","hilightedSel","_hilight","unhilight","_immutable","_plays","_plays2","_defaults","_defaults2","_template","_template2","fromJS","CHARTS","baseChart","mergeDeep","plays","defaults","toJS","TEMPLATE","publics","PUBLIC_METHODS","_ref","drawedSelection","mouseover","mouseout","chart","_ref2","remove","classed","DEFAULT_TEMPLATE","YCOL_TEMPLATE","varTmpl","_var","getYColTemplate","yCol","yVar","xVar","yDt","_typeof","Symbol","iterator","groupCol","multiData","_ret","groups","_ret2","yValues","_objectDestructuringEmpty","TypeError","WRAPPER_TEMPLATE","ITEM_TEMPLATE","cssNamespace","_ref2$opts","className","_data","getKey","compare","_sort","sort","toString","mediaQuery","alreadyImportedModules","createClass","ctor","superClass","Iterable","isIterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","offset","Math","max","newArr","ii","ensureSize","iter","size","__iterate","returnTrue","wrapIndex","uint32Index","NaN","wholeSlice","begin","end","resolveBegin","resolveIndex","resolveEnd","defaultIndex","min","Iterator","iteratorValue","iteratorResult","done","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","object","_object","_keys","IterableSeq","_iterable","IteratorSeq","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","maybeIndexedSeqFromValue","seqIterate","reverse","useKeys","cache","maxIndex","entry","__iterateUncached","seqIterator","__iteratorUncached","json","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","is","valueA","valueB","valueOf","equals","deepEqual","__hash","notAssociative","entries","every","flipped","cacheResult","allEqual","bSize","has","NOT_SET","Repeat","times","_value","Infinity","EMPTY_REPEAT","invariant","condition","Range","step","abs","_start","_end","_step","ceil","EMPTY_RANGE","Collection","KeyedCollection","IndexedCollection","SetCollection","smi","i32","hash","h","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","uniqueID","assertNotInfinite","Map","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","count","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","prev","__prev","makeMap","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","shift","isLeafNode","mergeIntoNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","existing","deepMergerWith","mergeDeepWith","nextValue","collection","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","nextExisting","nextUpdated","popCount","setIn","idx","canEdit","newArray","spliceIn","newLen","after","spliceOut","pop","List","emptyList","isList","makeList","VNode","toArray","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","from","left","to","right","DONE","values","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","clear","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","OrderedMap","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","includes","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","isKeyedIterable","singleton","concatSeq","flatten","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","stack","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","some","validateEntry","resolveSize","forceIterator","keyPath","Record","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_name","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","names","setProp","Set","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","StackPrototype","_head","EMPTY_STACK","methods","keyCopier","getOwnPropertySymbols","keyMapper","entryMapper","not","neg","quoteString","JSON","stringify","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","imul","SLICE$0","Keyed","Indexed","DELETE","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","of","__toString","searchValue","lastIndexOf","other","possibleIndex","floor","offsetValue","WeakMap","keyValues","updateIn","deleteIn","updatedValue","merge","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","removed","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","oldSize","unshift","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","union","intersect","originalSet","subtract","peek","pushAll","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","returnValue","find","findEntry","sideEffect","joined","isFirst","reducer","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","first","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","keyOf","last","lastKeyOf","maxBy","minBy","rest","skip","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","chain","mapEntries","mapKeys","KeyedIterablePrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","Immutable","addStylesToDom","styles","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","createLinkElement","linkElement","rel","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","replaceText","cssNode","childNodes","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","mayRemove","textStore","replacement","Boolean","locals"],"mappings":"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","file":"d3-playbooks.riot-components.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(9);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {/* Riot v3.0.7, @license MIT */\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.riot = global.riot || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar __TAGS_CACHE = [];\n\tvar __TAG_IMPL = {};\n\tvar GLOBAL_MIXIN = '__global_mixin';\n\tvar ATTRS_PREFIX = 'riot-';\n\tvar REF_DIRECTIVES = ['data-ref', 'ref'];\n\tvar IS_DIRECTIVE = 'data-is';\n\tvar CONDITIONAL_DIRECTIVE = 'if';\n\tvar LOOP_DIRECTIVE = 'each';\n\tvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\n\tvar SHOW_DIRECTIVE = 'show';\n\tvar HIDE_DIRECTIVE = 'hide';\n\tvar T_STRING = 'string';\n\tvar T_OBJECT = 'object';\n\tvar T_UNDEF  = 'undefined';\n\tvar T_FUNCTION = 'function';\n\tvar XLINK_NS = 'http://www.w3.org/1999/xlink';\n\tvar XLINK_REGEX = /^xlink:(\\w+)/;\n\tvar WIN = typeof window === T_UNDEF ? undefined : window;\n\tvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n\tvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n\tvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n\tvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\n\tvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n\tvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\n\tvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n\tvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\t\n\t/**\n\t * Check whether a DOM node must be considered a part of an svg document\n\t * @param   { String } name -\n\t * @returns { Boolean } -\n\t */\n\tfunction isSVGTag(name) {\n\t  return RE_SVG_TAGS.test(name)\n\t}\n\t\n\t/**\n\t * Check Check if the passed argument is undefined\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBoolAttr(value) {\n\t  return RE_BOOL_ATTRS.test(value)\n\t}\n\t\n\t/**\n\t * Check if passed argument is a function\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(value) {\n\t  return typeof value === T_FUNCTION\n\t}\n\t\n\t/**\n\t * Check if passed argument is an object, exclude null\n\t * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(value) {\n\t  return value && typeof value === T_OBJECT // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Check if passed argument is undefined\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isUndefined(value) {\n\t  return typeof value === T_UNDEF\n\t}\n\t\n\t/**\n\t * Check if passed argument is a string\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isString(value) {\n\t  return typeof value === T_STRING\n\t}\n\t\n\t/**\n\t * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n\t * @param { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBlank(value) {\n\t  return isUndefined(value) || value === null || value === ''\n\t}\n\t\n\t/**\n\t * Check if passed argument is a kind of array\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isArray(value) {\n\t  return Array.isArray(value) || value instanceof Array\n\t}\n\t\n\t/**\n\t * Check whether object's property could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } -\n\t */\n\tfunction isWritable(obj, key) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t  return isUndefined(obj[key]) || descriptor && descriptor.writable\n\t}\n\t\n\t/**\n\t * Check if passed argument is a reserved name\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isReservedName(value) {\n\t  return RE_RESERVED_NAMES.test(value)\n\t}\n\t\n\tvar check = Object.freeze({\n\t\tisSVGTag: isSVGTag,\n\t\tisBoolAttr: isBoolAttr,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisUndefined: isUndefined,\n\t\tisString: isString,\n\t\tisBlank: isBlank,\n\t\tisArray: isArray,\n\t\tisWritable: isWritable,\n\t\tisReservedName: isReservedName\n\t});\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Create a document fragment\n\t * @returns { Object } document fragment\n\t */\n\tfunction createFrag() {\n\t  return document.createDocumentFragment()\n\t}\n\t\n\t/**\n\t * Create a document text node\n\t * @returns { Object } create a text node to use as placeholder\n\t */\n\tfunction createDOMPlaceholder() {\n\t  return document.createTextNode('')\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - should we use a SVG as parent node?\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name, isSvg) {\n\t  return isSvg ?\n\t    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n\t    document.createElement(name)\n\t}\n\t\n\t/**\n\t * Get the outer html of any DOM node SVGs included\n\t * @param   { Object } el - DOM node to parse\n\t * @returns { String } el.outerHTML\n\t */\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML)\n\t    { return el.outerHTML }\n\t  // some browsers do not support outerHTML on the SVGs tags\n\t  else {\n\t    var container = mkEl('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we'll inject new html\n\t * @param { String } html - html to inject\n\t */\n\tfunction setInnerHTML(container, html) {\n\t  if (!isUndefined(container.innerHTML))\n\t    { container.innerHTML = html; }\n\t    // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml');\n\t    var node = container.ownerDocument.importNode(doc.documentElement, true);\n\t    container.appendChild(node);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name);\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  var xlink = XLINK_REGEX.exec(name);\n\t  if (xlink && xlink[1])\n\t    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n\t  else\n\t    { dom.setAttribute(name, val); }\n\t}\n\t\n\t/**\n\t * Insert safely a tag to fix #1962 #1649\n\t * @param   { HTMLElement } root - children container\n\t * @param   { HTMLElement } curr - node to insert\n\t * @param   { HTMLElement } next - node that should preceed the current node inserted\n\t */\n\tfunction safeInsert(root, curr, next) {\n\t  root.insertBefore(curr, next.parentNode && next);\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttrs(html, fn) {\n\t  if (!html)\n\t    { return }\n\t  var m;\n\t  while (m = RE_HTML_ATTRS.exec(html))\n\t    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t * @param   { Object }   context - fn can optionally return an object, which is passed to children\n\t */\n\tfunction walkNodes(dom, fn, context) {\n\t  if (dom) {\n\t    var res = fn(dom, context);\n\t    var next;\n\t    // stop the recursion\n\t    if (res === false) { return }\n\t\n\t    dom = dom.firstChild;\n\t\n\t    while (dom) {\n\t      next = dom.nextSibling;\n\t      walkNodes(dom, fn, res);\n\t      dom = next;\n\t    }\n\t  }\n\t}\n\t\n\tvar dom = Object.freeze({\n\t\t$$: $$,\n\t\t$: $,\n\t\tcreateFrag: createFrag,\n\t\tcreateDOMPlaceholder: createDOMPlaceholder,\n\t\tmkEl: mkEl,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tsetInnerHTML: setInnerHTML,\n\t\tremAttr: remAttr,\n\t\tgetAttr: getAttr,\n\t\tsetAttr: setAttr,\n\t\tsafeInsert: safeInsert,\n\t\twalkAttrs: walkAttrs,\n\t\twalkNodes: walkNodes\n\t});\n\t\n\tvar styleNode;\n\tvar cssTextProp;\n\tvar byName = {};\n\tvar remainder = [];\n\tvar needsInject = false;\n\t\n\t// skip the following code on the server\n\tif (WIN) {\n\t  styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style');\n\t    setAttr(newNode, 'type', 'text/css');\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]');\n\t    if (userNode) {\n\t      if (userNode.id) { newNode.id = userNode.id; }\n\t      userNode.parentNode.replaceChild(newNode, userNode);\n\t    }\n\t    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\t\n\t    return newNode\n\t  })();\n\t  cssTextProp = styleNode.styleSheet;\n\t}\n\t\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = {\n\t  styleNode: styleNode,\n\t  /**\n\t   * Save a tag style to be later injected into DOM\n\t   * @param { String } css - css string\n\t   * @param { String } name - if it's passed we will map the css to a tagname\n\t   */\n\t  add: function add(css, name) {\n\t    if (name) { byName[name] = css; }\n\t    else { remainder.push(css); }\n\t    needsInject = true;\n\t  },\n\t  /**\n\t   * Inject all previously saved tag styles into DOM\n\t   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t   */\n\t  inject: function inject() {\n\t    if (!WIN || !needsInject) { return }\n\t    needsInject = false;\n\t    var style = Object.keys(byName)\n\t      .map(function(k) { return byName[k] })\n\t      .concat(remainder).join('\\n');\n\t    if (cssTextProp) { cssTextProp.cssText = style; }\n\t    else { styleNode.innerHTML = style; }\n\t  }\n\t};\n\t\n\t/**\n\t * The riot template engine\n\t * @version v3.0.1\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\t/* global riot */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\t\n\t    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }';\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ];\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings;\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) { bp = _cache; }\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) { return _pairs }\n\t\n\t    var arr = pair.split(' ');\n\t\n\t    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n\t    arr[6] = _rewrite(_pairs[6], arr);\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n\t    arr[8] = pair;\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) { _bp = _cache; }\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6];\n\t\n\t    isexpr = start = re.lastIndex = 0;\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index;\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos));\n\t        start = re.lastIndex;\n\t        re = _bp[6 + (isexpr ^= 1)];\n\t        re.lastIndex = start;\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start));\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'));\n\t      } else {\n\t        parts.push(s);\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch];\n\t\n\t      recch.lastIndex = ix;\n\t      ix = 1;\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) { break }\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  };\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  };\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9]);\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  };\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  };\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair);\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite;\n\t      _cache[9] = _regex(_pairs[9]);\n\t    }\n\t    cachedBrackets = pair;\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b;\n\t\n\t    o = o || {};\n\t    b = o.brackets;\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    });\n\t    _settings = o;\n\t    _reset(b);\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  });\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n\t  _brackets.set = _reset;\n\t\n\t  _brackets.R_STRINGS = R_STRINGS;\n\t  _brackets.R_MLCOMMS = R_MLCOMMS;\n\t  _brackets.S_QBLOCKS = S_QBLOCKS;\n\t\n\t  return _brackets\n\t\n\t})();\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {};\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) { return str }\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr;\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys;\n\t\n\t  // istanbul ignore next\n\t  _tmpl.clearCache = function () { _cache = {}; };\n\t\n\t  _tmpl.errorHandler = null;\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    err.riotData = {\n\t      tagName: ctx && ctx.root && ctx.root.tagName,\n\t      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t    };\n\t\n\t    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\t    else if (\n\t      typeof console !== 'undefined' &&\n\t      typeof console.error === 'function'\n\t    ) {\n\t      if (err.riotData.tagName) {\n\t        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName.toLowerCase());\n\t      }\n\t      console.error(err);\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str);\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\t\n\t    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = String.fromCharCode(0x2057),\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g;\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = [];\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i];\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) { list[j++] = expr; }\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")';\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr);\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      });\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    };\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match;\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g;\n\t\n\t        expr = RegExp.rightContext;\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\t\n\t        jsb  = expr.slice(0, match.index);\n\t        expr = RegExp.rightContext;\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key);\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch];\n\t\n\t      ir.lastIndex = re.lastIndex;\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) { ++lv; }\n\t        else if (!--lv) { break }\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex;\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb;\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length;\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\t          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos));\n\t        }\n\t      }\n\t      return match\n\t    });\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"';\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)';\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  _tmpl.version = brackets.version = 'v3.0.1';\n\t\n\t  return _tmpl\n\t\n\t})();\n\t\n\tvar observable$1 = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {};\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice;\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          { (callbacks[event] = callbacks[event] || []).push(fn); }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) { callbacks = {}; }\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event];\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) { arr.splice(i--, 1); }\n\t            }\n\t          } else { delete callbacks[event]; }\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on);\n\t          fn.apply(el, arguments);\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t        var arguments$1 = arguments;\n\t\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i;\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments$1[i + 1]; // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0);\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args);\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          { el.trigger.apply(el, ['*', event].concat(args)); }\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  });\n\t\n\t  return el\n\t\n\t};\n\t\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } list - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(list, fn) {\n\t  var len = list ? list.length : 0;\n\t\n\t  for (var i = 0, el; i < len; ++i) {\n\t    el = list[i];\n\t    // return false -> current item was removed by fn during the loop\n\t    if (fn(el, i) === false)\n\t      { i--; }\n\t  }\n\t  return list\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } array - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } -\n\t */\n\tfunction contains(array, item) {\n\t  return ~array.indexOf(item)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } str - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(str) {\n\t  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } str - source string\n\t * @param   { String } value - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(str, value) {\n\t  return str.slice(0, value.length) === value\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t * @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options));\n\t  return el\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments;\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          { src[key] = obj[key]; }\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\tvar misc = Object.freeze({\n\t\teach: each,\n\t\tcontains: contains,\n\t\ttoCamel: toCamel,\n\t\tstartsWith: startsWith,\n\t\tdefineProperty: defineProperty,\n\t\textend: extend\n\t});\n\t\n\tvar EVENTS_PREFIX_REGEX = /^on/;\n\t\n\t/**\n\t * Trigger DOM events\n\t * @param   { HTMLElement } dom - dom element target of the event\n\t * @param   { Function } handler - user function\n\t * @param   { Object } e - event object\n\t */\n\tfunction handleEvent(dom, handler, e) {\n\t  var ptag = this._parent,\n\t    item = this._item;\n\t\n\t  if (!item)\n\t    { while (ptag && !item) {\n\t      item = ptag._item;\n\t      ptag = ptag._parent;\n\t    } }\n\t\n\t  // override the event properties\n\t  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n\t  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n\t  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\t\n\t  e.item = item;\n\t\n\t  handler.call(this, e);\n\t\n\t  if (!e.preventUpdate) {\n\t    var p = getImmediateCustomParentTag(this);\n\t    // fixes #2083\n\t    if (p.isMounted) { p.update(); }\n\t  }\n\t}\n\t\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t  var eventName,\n\t    cb = handleEvent.bind(tag, dom, handler);\n\t\n\t  if (!dom.addEventListener) {\n\t    dom[name] = cb;\n\t    return\n\t  }\n\t\n\t  // avoid to bind twice the same event\n\t  dom[name] = null;\n\t\n\t  // normalize event name\n\t  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\t\n\t  // cache the callback directly on the DOM node\n\t  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\t\n\t  if (dom._riotEvents[name])\n\t    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\t\n\t  dom._riotEvents[name] = cb;\n\t  dom.addEventListener(eventName, cb, false);\n\t}\n\t\n\t/**\n\t * Update dynamically created data-is tags with changing expressions\n\t * @param { Object } expr - expression tag and expression info\n\t * @param { Tag } parent - parent for tag creation\n\t */\n\tfunction updateDataIs(expr, parent) {\n\t  var tagName = tmpl(expr.value, parent),\n\t    conf;\n\t\n\t  if (expr.tag && expr.tagName === tagName) {\n\t    expr.tag.update();\n\t    return\n\t  }\n\t\n\t  // sync _parent to accommodate changing tagnames\n\t  if (expr.tag) {\n\t    each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n\t    expr.tag.unmount(true);\n\t  }\n\t\n\t  expr.impl = __TAG_IMPL[tagName];\n\t  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n\t  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n\t  expr.tagName = tagName;\n\t  expr.tag.mount();\n\t\n\t  // parent is the placeholder tag, not the dynamic tag so clean up\n\t  parent.on('unmount', function () {\n\t    var delName = expr.tag.opts.dataIs,\n\t      tags = expr.tag.parent.tags,\n\t      _tags = expr.tag._parent.tags;\n\t    arrayishRemove(tags, delName, expr.tag);\n\t    arrayishRemove(_tags, delName, expr.tag);\n\t    expr.tag.unmount();\n\t  });\n\t}\n\t\n\t/**\n\t * Update on single tag expression\n\t * @this Tag\n\t * @param { Object } expr - expression logic\n\t * @returns { undefined }\n\t */\n\tfunction updateExpression(expr) {\n\t  var dom = expr.dom,\n\t    attrName = expr.attr,\n\t    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n\t    value = tmpl(expr.expr, this),\n\t    isValueAttr = attrName === 'riot-value',\n\t    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n\t    parent = dom && (expr.parent || dom.parentNode),\n\t    old;\n\t\n\t  if (expr.bool)\n\t    { value = value ? attrName : false; }\n\t  else if (isUndefined(value) || value === null)\n\t    { value = ''; }\n\t\n\t  if (expr._riot_id) { // if it's a tag\n\t    if (expr.isMounted) {\n\t      expr.update();\n\t\n\t    // if it hasn't been mounted yet, do that now.\n\t    } else {\n\t      expr.mount();\n\t\n\t      if (isVirtual) {\n\t        var frag = document.createDocumentFragment();\n\t        makeVirtual.call(expr, frag);\n\t        expr.root.parentElement.replaceChild(frag, expr.root);\n\t      }\n\t    }\n\t    return\n\t  }\n\t\n\t  old = expr.value;\n\t  expr.value = value;\n\t\n\t  if (expr.update) {\n\t    expr.update();\n\t    return\n\t  }\n\t\n\t  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n\t  if (old === value) { return }\n\t  // no change, so nothing more to do\n\t  if (isValueAttr && dom.value === value) { return }\n\t\n\t  // textarea and text nodes have no attribute name\n\t  if (!attrName) {\n\t    // about #815 w/o replace: the browser converts the value to a string,\n\t    // the comparison by \"==\" does too, but not in the server\n\t    value += '';\n\t    // test for parent avoids error with invalid assignment to nodeValue\n\t    if (parent) {\n\t      // cache the parent node because somehow it will become null on IE\n\t      // on the next iteration\n\t      expr.parent = parent;\n\t      if (parent.tagName === 'TEXTAREA') {\n\t        parent.value = value;                    // #1113\n\t        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n\t      }                                         // will be available on 'updated'\n\t      else { dom.nodeValue = value; }\n\t    }\n\t    return\n\t  }\n\t\n\t  // remove original attribute\n\t  if (!expr.isAttrRemoved || !value) {\n\t    remAttr(dom, attrName);\n\t    expr.isAttrRemoved = true;\n\t  }\n\t\n\t  // event handler\n\t  if (isFunction(value)) {\n\t    setEventHandler(attrName, value, dom, this);\n\t  // show / hide\n\t  } else if (isToggle) {\n\t    if (attrName === HIDE_DIRECTIVE) { value = !value; }\n\t    dom.style.display = value ? '' : 'none';\n\t  // field value\n\t  } else if (isValueAttr) {\n\t    dom.value = value;\n\t  // <img src=\"{ expr }\">\n\t  } else if (startsWith(attrName, ATTRS_PREFIX) && attrName !== IS_DIRECTIVE) {\n\t    attrName = attrName.slice(ATTRS_PREFIX.length);\n\t    if (CASE_SENSITIVE_ATTRIBUTES[attrName])\n\t      { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n\t    if (value != null)\n\t      { setAttr(dom, attrName, value); }\n\t  } else {\n\t    // <select> <option selected={true}> </select>\n\t    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value) {\n\t      parent.value = dom.value;\n\t    } if (expr.bool) {\n\t      dom[attrName] = value;\n\t      if (!value) { return }\n\t    } if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      setAttr(dom, attrName, value);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Update all the expressions in a Tag instance\n\t * @this Tag\n\t * @param { Array } expressions - expression that must be re evaluated\n\t */\n\tfunction updateAllExpressions(expressions) {\n\t  each(expressions, updateExpression.bind(this));\n\t}\n\t\n\tvar IfExpr = {\n\t  init: function init(dom, tag, expr) {\n\t    remAttr(dom, CONDITIONAL_DIRECTIVE);\n\t    this.tag = tag;\n\t    this.expr = expr;\n\t    this.stub = document.createTextNode('');\n\t    this.pristine = dom;\n\t\n\t    var p = dom.parentNode;\n\t    p.insertBefore(this.stub, dom);\n\t    p.removeChild(dom);\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var newValue = tmpl(this.expr, this.tag);\n\t\n\t    if (newValue && !this.current) { // insert\n\t      this.current = this.pristine.cloneNode(true);\n\t      this.stub.parentNode.insertBefore(this.current, this.stub);\n\t\n\t      this.expressions = [];\n\t      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n\t    } else if (!newValue && this.current) { // remove\n\t      unmountAll(this.expressions);\n\t      if (this.current._tag) {\n\t        this.current._tag.unmount();\n\t      } else if (this.current.parentNode)\n\t        { this.current.parentNode.removeChild(this.current); }\n\t      this.current = null;\n\t      this.expressions = [];\n\t    }\n\t\n\t    if (newValue) { updateAllExpressions.call(this.tag, this.expressions); }\n\t  },\n\t  unmount: function unmount() {\n\t    unmountAll(this.expressions || []);\n\t    delete this.pristine;\n\t    delete this.parentNode;\n\t    delete this.stub;\n\t  }\n\t};\n\t\n\tvar RefExpr = {\n\t  init: function init(dom, parent, attrName, attrValue) {\n\t    this.dom = dom;\n\t    this.attr = attrName;\n\t    this.rawValue = attrValue;\n\t    this.parent = parent;\n\t    this.hasExp = tmpl.hasExpr(attrValue);\n\t    this.firstRun = true;\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var value = this.rawValue;\n\t    if (this.hasExp)\n\t      { value = tmpl(this.rawValue, this.parent); }\n\t\n\t    // if nothing changed, we're done\n\t    if (!this.firstRun && value === this.value) { return }\n\t\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t\n\t    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\t    var tagOrDom = this.tag || this.dom;\n\t\n\t    // the name changed, so we need to remove it from the old key (if present)\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t\n\t    if (isBlank(value)) {\n\t      // if the value is blank, we remove it\n\t      remAttr(this.dom, this.attr);\n\t    } else {\n\t      // add it to the refs of parent tag (this behavior was changed >=3.0)\n\t      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n\t      // set the actual DOM attr\n\t      setAttr(this.dom, this.attr, value);\n\t    }\n\t    this.value = value;\n\t    this.firstRun = false;\n\t  },\n\t  unmount: function unmount() {\n\t    var tagOrDom = this.tag || this.dom;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t    delete this.dom;\n\t    delete this.parent;\n\t  }\n\t};\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @param   { Object } base - prototype object for the new item\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val, base) {\n\t  var item = base ? Object.create(base) : {};\n\t  item[expr.key] = key;\n\t  if (expr.pos) { item[expr.pos] = val; }\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t * @param   { String } tagName - key used to identify the type of tag\n\t */\n\tfunction unmountRedundant(items, tags, tagName) {\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t;\n\t\n\t  while (i > j) {\n\t    t = tags[--i];\n\t    tags.splice(i, 1);\n\t    t.unmount();\n\t    arrayishRemove(t.parent, tagName, t, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @this Tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(i) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(this.tags), function (tagName) {\n\t    var tag = this$1.tags[tagName];\n\t    if (isArray(tag))\n\t      { each(tag, function (t) {\n\t        moveChildTag.apply(t, [tagName, i]);\n\t      }); }\n\t    else\n\t      { moveChildTag.apply(tag, [tagName, i]); }\n\t  });\n\t}\n\t\n\t/**\n\t * Move a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction move(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { moveVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Insert and mount a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction insert(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Append a new tag into the DOM\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction append(root, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.call(this, root); }\n\t  else\n\t    { root.appendChild(this.root); }\n\t}\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { HTMLElement } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t * @returns { Object } expression object for this each loop\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, LOOP_DIRECTIVE);\n\t\n\t  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n\t    tagName = getTagName(dom),\n\t    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n\t    useRoot = RE_SPECIAL_TAGS.test(tagName),\n\t    parentNode = dom.parentNode,\n\t    ref = createDOMPlaceholder(),\n\t    child = getTag(dom),\n\t    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isLoop = true,\n\t    isAnonymous = !__TAG_IMPL[tagName],\n\t    isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr);\n\t  expr.isLoop = true;\n\t\n\t  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  parentNode.insertBefore(ref, dom);\n\t  parentNode.removeChild(dom);\n\t\n\t  expr.update = function updateEach() {\n\t\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      frag = createFrag(),\n\t      isObject$$1 = !isArray(items),\n\t      root = ref.parentNode;\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (isObject$$1) {\n\t      hasKeys = items || false;\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, items[key], key)\n\t        }) : [];\n\t    } else {\n\t      hasKeys = false;\n\t    }\n\t\n\t    if (ifExpr) {\n\t      items = items.filter(function(item, i) {\n\t        if (expr.key && !isObject$$1)\n\t          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\t\n\t        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n\t      });\n\t    }\n\t\n\t    // loop all the new items\n\t    each(items, function(item, i) {\n\t      // reorder only if the items are objects\n\t      var\n\t        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        isNew = !~oldPos,\n\t        mustAppend = i <= tags.length,\n\t        pos = !isNew && doReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos];\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\t\n\t      // new tag\n\t      if (\n\t        doReorder && isNew // by default we always try to reorder the DOM elements\n\t        ||\n\t        !doReorder && !tag // with no-reorder we just update the old tags\n\t      ) {\n\t        tag = new Tag$1(impl, {\n\t          parent: parent,\n\t          isLoop: isLoop,\n\t          isAnonymous: isAnonymous,\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML);\n\t\n\t        // mount the tag\n\t        tag.mount();\n\t\n\t        if (mustAppend)\n\t          { append.apply(tag, [frag || root, isVirtual]); }\n\t        else\n\t          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\t\n\t        if (!mustAppend) { oldItems.splice(i, 0, item); }\n\t        tags.splice(i, 0, tag);\n\t        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n\t        pos = i; // handled here so no move\n\t      } else { tag.update(item); }\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (pos !== i && doReorder) {\n\t        // #closes 2040\n\t        if (contains(items, oldItems[i])) {\n\t          move.apply(tag, [root, tags[i], isVirtual]);\n\t        }\n\t        // update the position attribute if it exists\n\t        if (expr.pos) { tag[expr.pos] = i; }\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item;\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent);\n\t    });\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags, tagName);\n\t\n\t    // clone the items array\n\t    oldItems = items.slice();\n\t\n\t    root.insertBefore(frag, ref);\n\t  };\n\t\n\t  expr.unmount = function() {\n\t    each(tags, function(t) { t.unmount(); });\n\t  };\n\t\n\t  return expr\n\t}\n\t\n\t/**\n\t * Walk the tag DOM to detect the expressions to evaluate\n\t * @this Tag\n\t * @param   { HTMLElement } root - root tag where we will start digging the expressions\n\t * @param   { Array } expressions - empty array where the expressions will be added\n\t * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n\t * @returns { Object } an object containing the root noode and the dom tree\n\t */\n\tfunction parseExpressions(root, expressions, mustIncludeRoot) {\n\t  var this$1 = this;\n\t\n\t  var tree = {parent: {children: expressions}};\n\t\n\t  walkNodes(root, function (dom, ctx) {\n\t    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n\t    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\t\n\t    // text node\n\t    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n\t      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\t\n\t    if (type !== 1) { return ctx } // not an element\n\t\n\t    // loop. each does it's own thing (for now)\n\t    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n\t      parent.children.push(_each(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    // if-attrs become the new parent. Any following expressions (either on the current\n\t    // element, or below it) become children of this expression.\n\t    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n\t      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n\t      if (tmpl.hasExpr(expr)) {\n\t        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n\t        return false\n\t      }\n\t    }\n\t\n\t    // if this is a tag, stop traversing here.\n\t    // we ignore the root, since parseExpressions is called while we're mounting that root\n\t    tagImpl = getTag(dom);\n\t    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n\t      var conf = {root: dom, parent: this$1, hasImpl: true};\n\t      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n\t      return false\n\t    }\n\t\n\t    // attribute expressions\n\t    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n\t      if (!expr) { return }\n\t      parent.children.push(expr);\n\t    }]);\n\t\n\t    // whatever the parent is, all child elements get the same parent.\n\t    // If this element had an if-attr, that's the parent for all child elements\n\t    return {parent: parent}\n\t  }, tree);\n\t\n\t  return { tree: tree, root: root }\n\t}\n\t\n\t/**\n\t * Calls `fn` for every attribute on an element. If that attr has an expression,\n\t * it is also passed to fn.\n\t * @this Tag\n\t * @param   { HTMLElement } dom - dom node to parse\n\t * @param   { Array } attrs - array of attributes\n\t * @param   { Function } fn - callback to exec on any iteration\n\t */\n\tfunction parseAttributes(dom, attrs, fn) {\n\t  var this$1 = this;\n\t\n\t  each(attrs, function (attr) {\n\t    var name = attr.name, bool = isBoolAttr(name), expr;\n\t\n\t    if (contains(REF_DIRECTIVES, name)) {\n\t      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n\t    } else if (tmpl.hasExpr(attr.value)) {\n\t      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n\t    }\n\t\n\t    fn(attr, expr);\n\t  });\n\t}\n\t\n\t/*\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\t\n\tvar reHasYield  = /<yield\\b/i;\n\tvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n\tvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n\tvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n\tvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n\tvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n\tvar GENERIC = 'div';\n\t\n\t\n\t/*\n\t  Creates the root element for table or select child elements:\n\t  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t*/\n\tfunction specialTags(el, tmpl, tagName) {\n\t\n\t  var\n\t    select = tagName[0] === 'o',\n\t    parent = select ? 'select>' : 'table>';\n\t\n\t  // trim() is important here, this ensures we don't have artifacts,\n\t  // so we can check if we have only one element inside the parent\n\t  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n\t  parent = el.firstChild;\n\t\n\t  // returns the immediate parent if tr/th/td/col is the only element, if not\n\t  // returns the whole tree, as this can include additional elements\n\t  if (select) {\n\t    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n\t  } else {\n\t    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t    var tname = rootEls[tagName];\n\t    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n\t  }\n\t  return parent\n\t}\n\t\n\t/*\n\t  Replace the yield tag from any tag template with the innerHTML of the\n\t  original tag in the page\n\t*/\n\tfunction replaceYield(tmpl, html) {\n\t  // do nothing if no yield\n\t  if (!reHasYield.test(tmpl)) { return tmpl }\n\t\n\t  // be careful with #1343 - string on the source having `$1`\n\t  var src = {};\n\t\n\t  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t    src[ref] = src[ref] || text;   // preserve first definition\n\t    return ''\n\t  }).trim();\n\t\n\t  return tmpl\n\t    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t      return src[ref] || def || ''\n\t    })\n\t    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t      return html || def || ''\n\t    })\n\t}\n\t\n\t/**\n\t * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t *\n\t * @param   { String } tmpl  - The template coming from the custom tag definition\n\t * @param   { String } html - HTML content that comes from the DOM element where you\n\t *           will mount the tag, mostly the original tag in the page\n\t * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n\t * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n\t */\n\tfunction mkdom(tmpl, html, checkSvg) {\n\t  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n\t    tagName = match && match[1].toLowerCase(),\n\t    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\t\n\t  // replace all the yield tags with the tag inner html\n\t  tmpl = replaceYield(tmpl, html);\n\t\n\t  /* istanbul ignore next */\n\t  if (tblTags.test(tagName))\n\t    { el = specialTags(el, tmpl, tagName); }\n\t  else\n\t    { setInnerHTML(el, tmpl); }\n\t\n\t  el.stub = true;\n\t\n\t  return el\n\t}\n\t\n\t/**\n\t * Another way to create a riot tag a bit more es6 friendly\n\t * @param { HTMLElement } el - tag DOM selector or DOM node/s\n\t * @param { Object } opts - tag logic\n\t * @returns { Tag } new riot tag instance\n\t */\n\tfunction Tag$2(el, opts) {\n\t  // get the tag properties from the class constructor\n\t  var ref = this;\n\t  var name = ref.name;\n\t  var tmpl = ref.tmpl;\n\t  var css = ref.css;\n\t  var attrs = ref.attrs;\n\t  var onCreate = ref.onCreate;\n\t  // register a new tag and cache the class prototype\n\t  if (!__TAG_IMPL[name]) {\n\t    tag$1(name, tmpl, css, attrs, onCreate);\n\t    // cache the class constructor\n\t    __TAG_IMPL[name].class = this.constructor;\n\t  }\n\t\n\t  // mount the tag using the class instance\n\t  mountTo(el, name, opts, this);\n\t  // inject the component css\n\t  if (css) { styleManager.inject(); }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag$1(name, tmpl, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs;\n\t\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css;\n\t      css = '';\n\t    } else\n\t      { attrs = ''; }\n\t  }\n\t\n\t  if (css) {\n\t    if (isFunction(css))\n\t      { fn = css; }\n\t    else\n\t      { styleManager.add(css); }\n\t  }\n\t\n\t  name = name.toLowerCase();\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag2$1(name, tmpl, css, attrs, fn) {\n\t  if (css)\n\t    { styleManager.add(css, name); }\n\t\n\t  var exists = !!__TAG_IMPL[name];\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  if (exists && util.hotReloader)\n\t    { util.hotReloader(name); }\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { * } selector - tag DOM selector or DOM node/s\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\tfunction mount$1(selector, tagName, opts) {\n\t  var tags = [];\n\t\n\t  function pushTagsTo(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, IS_DIRECTIVE);\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName;\n\t        setAttr(root, IS_DIRECTIVE, tagName);\n\t      }\n\t\n\t      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\t\n\t      if (tag$$1)\n\t        { tags.push(tag$$1); }\n\t    } else if (root.length)\n\t      { each(root, pushTagsTo); } // assume nodeList\n\t  }\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject();\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName;\n\t    tagName = 0;\n\t  }\n\t\n\t  var elem;\n\t  var allTags;\n\t\n\t  // crawl the DOM to find the tag\n\t  if (isString(selector)) {\n\t    selector = selector === '*' ?\n\t      // select all registered tags\n\t      // & tags found with the riot-tag attribute set\n\t      allTags = selectTags() :\n\t      // or just the ones named like the selector\n\t      selector + selectTags(selector.split(/, */));\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    elem = selector ? $$(selector) : [];\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    { elem = selector; }\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectTags();\n\t    // if the root els it's just a single tag\n\t    if (elem.tagName)\n\t      { elem = $$(tagName, elem); }\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = [];\n\t\n\t      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\t\n\t      elem = nodeList;\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0;\n\t  }\n\t\n\t  pushTagsTo(elem);\n\t\n\t  return tags\n\t}\n\t\n\t// Create a mixin that could be globally shared across all the tags\n\tvar mixins = {};\n\tvar globals = mixins[GLOBAL_MIXIN] = {};\n\tvar _id = 0;\n\t\n\t/**\n\t * Create/Return a mixin by its name\n\t * @param   { String }  name - mixin name (global mixin if object)\n\t * @param   { Object }  mix - mixin logic\n\t * @param   { Boolean } g - is global?\n\t * @returns { Object }  the mixin logic\n\t */\n\tfunction mixin$1(name, mix, g) {\n\t  // Unnamed global\n\t  if (isObject(name)) {\n\t    mixin$1((\"__unnamed_\" + (_id++)), name, true);\n\t    return\n\t  }\n\t\n\t  var store = g ? globals : mixins;\n\t\n\t  // Getter\n\t  if (!mix) {\n\t    if (isUndefined(store[name]))\n\t      { throw new Error('Unregistered mixin: ' + name) }\n\t\n\t    return store[name]\n\t  }\n\t\n\t  // Setter\n\t  store[name] = isFunction(mix) ?\n\t    extend(mix.prototype, store[name] || {}) && mix :\n\t    extend(store[name] || {}, mix);\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\tfunction update$1() {\n\t  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n\t}\n\t\n\tfunction unregister$1(name) {\n\t  delete __TAG_IMPL[name];\n\t}\n\t\n\t// counter to give a unique id to all the Tag instances\n\tvar __uid = 0;\n\t\n\t/**\n\t * We need to update opts for this tag. That requires updating the expressions\n\t * in any attributes on the tag, and then copying the result onto opts.\n\t * @this Tag\n\t * @param   {Boolean} isLoop - is it a loop tag?\n\t * @param   { Tag }  parent - parent tag node\n\t * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n\t * @param   { Object }  opts - tag options\n\t * @param   { Array }  instAttrs - tag attributes array\n\t */\n\tfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n\t  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n\t  // (and only this case) we don't need to do updateOpts, because the regular parse\n\t  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n\t  if (isLoop && isAnonymous) { return }\n\t\n\t  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\t  each(instAttrs, function (attr) {\n\t    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n\t    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Tag class\n\t * @constructor\n\t * @param { Object } impl - it contains the tag template, and logic\n\t * @param { Object } conf - tag options\n\t * @param { String } innerHTML - html that eventually we need to inject in the tag\n\t */\n\tfunction Tag$1(impl, conf, innerHTML) {\n\t\n\t  var opts = extend({}, conf.opts),\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    isAnonymous = conf.isAnonymous,\n\t    item = cleanUpData(conf.item),\n\t    instAttrs = [], // All attributes on the Tag when it's first parsed\n\t    implAttrs = [], // expressions on this type of Tag\n\t    expressions = [],\n\t    root = conf.root,\n\t    tagName = conf.tagName || getTagName(root),\n\t    isVirtual = tagName === 'virtual',\n\t    propsInSyncWithParent = [],\n\t    dom;\n\t\n\t  // make this tag observable\n\t  observable$1(this);\n\t  // only call unmount if we have a valid __TAG_IMPL (has name property)\n\t  if (impl.name && root._tag) { root._tag.unmount(true); }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false;\n\t  root.isLoop = isLoop;\n\t\n\t  defineProperty(this, '_internal', {\n\t    isAnonymous: isAnonymous,\n\t    instAttrs: instAttrs,\n\t    innerHTML: innerHTML,\n\t    // these vars will be needed only for the virtual tags\n\t    virts: [],\n\t    tail: null,\n\t    head: null\n\t  });\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { root: root, opts: opts }, item);\n\t  // protect the \"tags\" and \"refs\" property from being overridden\n\t  defineProperty(this, 'parent', parent || null);\n\t  defineProperty(this, 'tags', {});\n\t  defineProperty(this, 'refs', {});\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'update', function tagUpdate(data) {\n\t    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data);\n\t\n\t    // inherit properties from the parent, but only for isAnonymous tags\n\t    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n\t    extend(this, data);\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t    if (this.isMounted) { this.trigger('update', data); }\n\t    updateAllExpressions.call(this, expressions);\n\t    if (this.isMounted) { this.trigger('updated'); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Add a mixin to this tag\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mixin', function tagMixin() {\n\t    var this$1 = this;\n\t\n\t    each(arguments, function (mix) {\n\t      var instance,\n\t        props = [],\n\t        obj;\n\t\n\t      mix = isString(mix) ? mixin$1(mix) : mix;\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix();\n\t      } else { instance = mix; }\n\t\n\t      var proto = Object.getPrototypeOf(instance);\n\t\n\t      // build multilevel prototype inheritance chain property list\n\t      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n\t      while (obj = Object.getPrototypeOf(obj || instance))\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(props, function (key) {\n\t        // bind methods to this\n\t        // allow mixins to override other properties/parent mixins\n\t        if (key !== 'init') {\n\t          // check for getters/setters\n\t          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n\t          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\t\n\t          // apply method only if it does not already exist on the instance\n\t          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n\t            Object.defineProperty(this$1, key, descriptor);\n\t          } else {\n\t            this$1[key] = isFunction(instance[key]) ?\n\t              instance[key].bind(this$1) :\n\t              instance[key];\n\t          }\n\t        }\n\t      });\n\t\n\t      // init method will be called automatically\n\t      if (instance.init)\n\t        { instance.init.bind(this$1)(); }\n\t    });\n\t    return this\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Mount the current tag instance\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mount', function tagMount() {\n\t    var this$1 = this;\n\t\n\t    root._tag = this; // keep a reference to the tag just created\n\t\n\t    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\t    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n\t      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n\t      attr.expr = expr;\n\t      instAttrs.push(attr);\n\t    }]);\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    implAttrs = [];\n\t    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n\t    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n\t      if (expr) { expressions.push(expr); }\n\t      else { setAttr(root, attr.name, attr.value); }\n\t    }]);\n\t\n\t    // children in loop should inherit from true parent\n\t    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\t\n\t    // initialiation\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t\n\t    // add global mixins\n\t    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\t\n\t    if (globalMixin) {\n\t      for (var i in globalMixin) {\n\t        if (globalMixin.hasOwnProperty(i)) {\n\t          this$1.mixin(globalMixin[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (impl.fn) { impl.fn.call(this, opts); }\n\t\n\t    this.trigger('before-mount');\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions.apply(this, [dom, expressions, false]);\n\t\n\t    this.update(item);\n\t\n\t    if (isLoop && isAnonymous) {\n\t      // update the root attribute for the looped elements\n\t      this.root = root = dom.firstChild;\n\t    } else {\n\t      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n\t      if (root.stub) { root = parent.root; }\n\t    }\n\t\n\t    defineProperty(this, 'root', root);\n\t    this.isMounted = true;\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!this.parent || this.parent.isMounted) {\n\t      this.trigger('mount');\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else { this.parent.one('mount', function () {\n\t      this$1.trigger('mount');\n\t    }); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Unmount the tag instance\n\t   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n\t    var this$1 = this;\n\t\n\t    var el = this.root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __TAGS_CACHE.indexOf(this);\n\t\n\t    this.trigger('before-unmount');\n\t\n\t    // clear all attributes coming from the mounted tag\n\t    walkAttrs(impl.attrs, function (name) {\n\t      if (startsWith(name, ATTRS_PREFIX))\n\t        { name = name.slice(ATTRS_PREFIX.length); }\n\t      remAttr(root, name);\n\t    });\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      { __TAGS_CACHE.splice(tagIndex, 1); }\n\t\n\t    if (p) {\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent);\n\t\n\t        if (isVirtual) {\n\t          Object.keys(this.tags).forEach(function (tagName) {\n\t            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n\t          });\n\t        } else {\n\t          arrayishRemove(ptag.tags, tagName, this);\n\t          if(parent !== ptag) // remove from _parent too\n\t            { arrayishRemove(parent.tags, tagName, this); }\n\t        }\n\t      } else {\n\t        while (el.firstChild) { el.removeChild(el.firstChild); }\n\t      }\n\t\n\t      if (!mustKeepRoot) {\n\t        p.removeChild(el);\n\t      } else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, IS_DIRECTIVE);\n\t      }\n\t    }\n\t\n\t    if (this._internal.virts) {\n\t      each(this._internal.virts, function (v) {\n\t        if (v.parentNode) { v.parentNode.removeChild(v); }\n\t      });\n\t    }\n\t\n\t    // allow expressions to unmount themselves\n\t    unmountAll(expressions);\n\t    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\t\n\t    this.trigger('unmount');\n\t    this.off('*');\n\t    this.isMounted = false;\n\t\n\t    delete this.root._tag;\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n\t    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Inherit properties from a target tag instance\n\t * @this Tag\n\t * @param   { Tag } target - tag where we will inherit properties\n\t * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n\t */\n\tfunction inheritFrom(target, propsInSyncWithParent) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(target), function (k) {\n\t    // some properties must be always in sync with the parent tag\n\t    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\t\n\t    if (isUndefined(this$1[k]) || mustSync) {\n\t      // track the property to keep in sync\n\t      // so we can keep it updated\n\t      if (!mustSync) { propsInSyncWithParent.push(k); }\n\t      this$1[k] = target[k];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @this Tag\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tagName, newPos) {\n\t  var parent = this.parent,\n\t    tags;\n\t  // no parent no move\n\t  if (!parent) { return }\n\t\n\t  tags = parent.tags[tagName];\n\t\n\t  if (isArray(tags))\n\t    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n\t  else { arrayishAdd(parent.tags, tagName, this); }\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag$1(child, opts, innerHTML),\n\t    tagName = opts.tagName || getTagName(opts.root, true),\n\t    ptag = getImmediateCustomParentTag(parent);\n\t  // fix for the parent attribute in the looped elements\n\t  defineProperty(tag, 'parent', ptag);\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent;\n\t\n\t  // add this tag to the custom parent tag\n\t  arrayishAdd(ptag.tags, tagName, tag);\n\t\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    { arrayishAdd(parent.tags, tagName, tag); }\n\t\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = '';\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag;\n\t  while (ptag._internal.isAnonymous) {\n\t    if (!ptag.parent) { break }\n\t    ptag = ptag.parent;\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Trigger the unmount method on all the expressions\n\t * @param   { Array } expressions - DOM expressions\n\t */\n\tfunction unmountAll(expressions) {\n\t  each(expressions, function(expr) {\n\t    if (expr instanceof Tag$1) { expr.unmount(true); }\n\t    else if (expr.unmount) { expr.unmount(); }\n\t  });\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom, skipDataIs) {\n\t  var child = getTag(dom),\n\t    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n\t  return namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t}\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n\t    { return data }\n\t\n\t  var o = {};\n\t  for (var key in data) {\n\t    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Set the property of an object for a given key. If something already\n\t * exists there, then it becomes an array containing both the old and new value.\n\t * @param { Object } obj - object on which to set the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be set\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t */\n\tfunction arrayishAdd(obj, key, value, ensureArray) {\n\t  var dest = obj[key];\n\t  var isArr = isArray(dest);\n\t\n\t  if (dest && dest === value) { return }\n\t\n\t  // if the key was never set, set it once\n\t  if (!dest && ensureArray) { obj[key] = [value]; }\n\t  else if (!dest) { obj[key] = value; }\n\t  // if it was an array and not yet set\n\t  else if (!isArr || isArr && !contains(dest, value)) {\n\t    if (isArr) { dest.push(value); }\n\t    else { obj[key] = [dest, value]; }\n\t  }\n\t}\n\t\n\t/**\n\t * Removes an item from an object at a given key. If the key points to an array,\n\t * then the item is just removed from the array.\n\t * @param { Object } obj - object on which to remove the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be removed\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t*/\n\tfunction arrayishRemove(obj, key, value, ensureArray) {\n\t  if (isArray(obj[key])) {\n\t    each(obj[key], function(item, i) {\n\t      if (item === value) { obj[key].splice(i, 1); }\n\t    });\n\t    if (!obj[key].length) { delete obj[key]; }\n\t    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n\t  } else\n\t    { delete obj[key]; } // otherwise just delete the key\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub)\n\t      { return true }\n\t    dom = dom.parentNode;\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts, ctx) {\n\t  var impl = __TAG_IMPL[tagName],\n\t    implClass = __TAG_IMPL[tagName].class,\n\t    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\t\n\t  // clear the inner html\n\t  root.innerHTML = '';\n\t\n\t  var conf = { root: root, opts: opts };\n\t  if (opts && opts.parent) { conf.parent = opts.parent; }\n\t\n\t  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount(true);\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n\t  }\n\t\n\t  return tag\n\t}\n\t\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @this Tag\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction makeVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var head = createDOMPlaceholder(),\n\t    tail = createDOMPlaceholder(),\n\t    frag = createFrag(),\n\t    sib, el;\n\t\n\t  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n\t  this._internal.tail = this.root.appendChild(tail);\n\t\n\t  el = this._internal.head;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    this$1._internal.virts.push(el); // hold for unmounting\n\t    el = sib;\n\t  }\n\t\n\t  if (target)\n\t    { src.insertBefore(frag, target._internal.head); }\n\t  else\n\t    { src.appendChild(frag); }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @this Tag\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t */\n\tfunction moveVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var el = this._internal.head,\n\t    frag = createFrag(),\n\t    sib;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    el = sib;\n\t    if (el === this$1._internal.tail) {\n\t      frag.appendChild(el);\n\t      src.insertBefore(frag, target._internal.head);\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Get selectors for tags\n\t * @param   { Array } tags - tag names to select\n\t * @returns { String } selector\n\t */\n\tfunction selectTags(tags) {\n\t  // select all tags\n\t  if (!tags) {\n\t    var keys = Object.keys(__TAG_IMPL);\n\t    return keys + selectTags(keys)\n\t  }\n\t\n\t  return tags\n\t    .filter(function (t) { return !/[^-\\w]/.test(t); })\n\t    .reduce(function (list, t) {\n\t      var name = t.trim().toLowerCase();\n\t      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n\t    }, '')\n\t}\n\t\n\t\n\tvar tags = Object.freeze({\n\t\tgetTag: getTag,\n\t\tinheritFrom: inheritFrom,\n\t\tmoveChildTag: moveChildTag,\n\t\tinitChildTag: initChildTag,\n\t\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\t\tunmountAll: unmountAll,\n\t\tgetTagName: getTagName,\n\t\tcleanUpData: cleanUpData,\n\t\tarrayishAdd: arrayishAdd,\n\t\tarrayishRemove: arrayishRemove,\n\t\tisInStub: isInStub,\n\t\tmountTo: mountTo,\n\t\tmakeVirtual: makeVirtual,\n\t\tmoveVirtual: moveVirtual,\n\t\tselectTags: selectTags\n\t});\n\t\n\t/**\n\t * Riot public api\n\t */\n\tvar settings = Object.create(brackets.settings);\n\t\n\tvar util = {\n\t  tmpl: tmpl,\n\t  brackets: brackets,\n\t  styleManager: styleManager,\n\t  vdom: __TAGS_CACHE,\n\t  styleNode: styleManager.styleNode,\n\t  // export the riot internal utils as well\n\t  dom: dom,\n\t  check: check,\n\t  misc: misc,\n\t  tags: tags\n\t};\n\t\n\t// export the core props/methods\n\tvar Tag$$1 = Tag$2;\n\tvar tag$$1 = tag$1;\n\tvar tag2$$1 = tag2$1;\n\tvar mount$$1 = mount$1;\n\tvar mixin$$1 = mixin$1;\n\tvar update$$1 = update$1;\n\tvar unregister$$1 = unregister$1;\n\tvar observable = observable$1;\n\t\n\tvar riot$1 = {\n\t  settings: settings,\n\t  util: util,\n\t  // core\n\t  Tag: Tag$$1,\n\t  tag: tag$$1,\n\t  tag2: tag2$$1,\n\t  mount: mount$$1,\n\t  mixin: mixin$$1,\n\t  update: update$$1,\n\t  unregister: unregister$$1,\n\t  observable: observable\n\t};\n\t\n\texports.settings = settings;\n\texports.util = util;\n\texports.Tag = Tag$$1;\n\texports.tag = tag$$1;\n\texports.tag2 = tag2$$1;\n\texports.mount = mount$$1;\n\texports.mixin = mixin$$1;\n\texports.update = update$$1;\n\texports.unregister = unregister$$1;\n\texports.observable = observable;\n\texports['default'] = riot$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tvar nargs = /\\{([0-9a-zA-Z_]+)\\}/g\n\t\n\tmodule.exports = template\n\t\n\tfunction template(string) {\n\t    var args\n\t\n\t    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\n\t        args = arguments[1]\n\t    } else {\n\t        args = new Array(arguments.length - 1)\n\t        for (var i = 1; i < arguments.length; ++i) {\n\t            args[i - 1] = arguments[i]\n\t        }\n\t    }\n\t\n\t    if (!args || !args.hasOwnProperty) {\n\t        args = {}\n\t    }\n\t\n\t    return string.replace(nargs, function replaceArg(match, i, index) {\n\t        var result\n\t\n\t        if (string[index - 1] === \"{\" &&\n\t            string[index + match.length] === \"}\") {\n\t            return i\n\t        } else {\n\t            result = args.hasOwnProperty(i) ? args[i] : null\n\t            if (result === null || result === undefined) {\n\t                return \"\"\n\t            }\n\t\n\t            return result\n\t        }\n\t    })\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('raw-html', '', '', '', function (opts) {\n\t  var _this = this;\n\t\n\t  this.updateContent = function () {\n\t    _this.root.innerHTML = _this.opts.content;\n\t  };\n\t\n\t  this.on('update', function () {\n\t    _this.updateContent();\n\t  });\n\t\n\t  this.updateContent();\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (node) {\n\t  node.classList.add('-hilight');\n\t  node.parentNode.appendChild(node);\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\t__webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\triot.tag2('riot-infobox', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"{opts.className} d3-playbooks__infobox {-empty: empty}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.empty = true;\n\t\n\t  this.opts.control.on(riot.EVT.updateInfobox, function (data) {\n\t    _this.update({\n\t      empty: false,\n\t      rawContent: (0, _stringTemplate2.default)(_this.opts.template, data)\n\t    });\n\t  });\n\t\n\t  this.opts.control.on(riot.EVT.emptyInfobox, function () {\n\t    _this.update({ empty: true });\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\t__webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\triot.tag2('riot-legend', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"{opts.className} d3-playbooks__legend\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.rawContent = (0, _stringTemplate2.default)(this.opts.templates.wrapper, {\n\t    body: this.opts.legendItems.map(function (l) {\n\t      return (0, _stringTemplate2.default)(_this.opts.templates.item, l);\n\t    }).join('')\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('riot-selector', '<select onchange=\"{hilight}\"> <option each=\"{label, i in labels}\" riot-value=\"{i}\" selected=\"{active === i}\">{label}</option> </select>', '', 'class=\"{opts.className} d3-playbooks__selector\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.active = 0;\n\t  this.data = this.opts.data;\n\t  this.labels = Object.keys(this.data);\n\t\n\t  this.hilight = function (e) {\n\t    var label = _this.labels[e.target.value];\n\t    var data = _this.data[label];\n\t    _this.opts.hilight(data);\n\t    _this.opts.control.trigger(riot.EVT.updateInfobox, data);\n\t  };\n\t\n\t  this.opts.control.on(riot.EVT.updateSelector, function (data) {\n\t    var active = _this.labels.indexOf(_this.opts.getLabel(data));\n\t    _this.update({ active: active });\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// render some base examples\n\texports.default = function () {\n\t\n\t  var chart = d3.playbooks.barChart({\n\t    elementId: 'chart1',\n\t    data: [['a', 'c', 'b'], ['1', 3, '2']]\n\t  }).render().legend({\n\t    wrapperTemplate: '<h3>Legend</h3><p>{body}</p>',\n\t    itemTemplate: 'The color for <strong>{label}</strong> is <em>{color}</em>.'\n\t  }).infobox({\n\t    element: '#my-infobox',\n\t    template: '<p><strong>Value for {x}:</strong> {y}</p>'\n\t  }).selector({\n\t    getLabel: function getLabel(d) {\n\t      return d.x + ' (' + d.y + ')';\n\t    },\n\t    sortItems: function sortItems(a, b) {\n\t      return b.y - a.y;\n\t    }\n\t  });\n\t\n\t  d3.playbooks.scatterChart({\n\t    elementId: 'chart2',\n\t    data: {\n\t      x: [1, 2, 3, 4, 6],\n\t      y: [2, 5, 1, 1, 8]\n\t    },\n\t    color: d3.schemeCategory10,\n\t    getLegendItems: function getLegendItems(C) {\n\t      return C.data.map(function (d) {\n\t        return {\n\t          label: 'Item ' + d.x,\n\t          color: C.getColor(d)\n\t        };\n\t      });\n\t    }\n\t  }).render().legend().infobox().selector();\n\t\n\t  d3.playbooks.multiLineChart({\n\t    elementId: 'chart3',\n\t    dataUrl: 'data/multiline.csv',\n\t    yCols: ['y1', 'y2', 'y3']\n\t  }).render().infobox();\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(15);\n\t\n\t__webpack_require__(30);\n\t\n\t__webpack_require__(13);\n\t\n\tvar _examples = __webpack_require__(8);\n\t\n\tvar _examples2 = _interopRequireDefault(_examples);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// event handling\n\t\n\t\n\t// additional stzle\n\t\n\t\n\t// exported stuff\n\tif (false) {\n\t  (0, _examples2.default)();\n\t}\n\t\n\t// dev mode\n\t// available components\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _hilight_node = __webpack_require__(4);\n\t\n\tvar _hilight_node2 = _interopRequireDefault(_hilight_node);\n\t\n\tvar _unhilight_node = __webpack_require__(19);\n\t\n\tvar _unhilight_node2 = _interopRequireDefault(_unhilight_node);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  control: null,\n\t  hilightNode: _hilight_node2.default,\n\t  unhilightNode: _unhilight_node2.default\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _mount_riot_tag = __webpack_require__(24);\n\t\n\tvar _mount_riot_tag2 = _interopRequireDefault(_mount_riot_tag);\n\t\n\tvar _get_legend_items = __webpack_require__(22);\n\t\n\tvar _get_legend_items2 = _interopRequireDefault(_get_legend_items);\n\t\n\tvar _get_legend_template = __webpack_require__(23);\n\t\n\tvar _get_legend_template2 = _interopRequireDefault(_get_legend_template);\n\t\n\tvar _get_infobox_template = __webpack_require__(21);\n\t\n\tvar _get_infobox_template2 = _interopRequireDefault(_get_infobox_template);\n\t\n\tvar _get_selector_data = __webpack_require__(25);\n\t\n\tvar _get_selector_data2 = _interopRequireDefault(_get_selector_data);\n\t\n\tvar _find_selection = __webpack_require__(17);\n\t\n\tvar _find_selection2 = _interopRequireDefault(_find_selection);\n\t\n\tvar _hilight_selection = __webpack_require__(18);\n\t\n\tvar _hilight_selection2 = _interopRequireDefault(_hilight_selection);\n\t\n\tvar _unhilight_selection = __webpack_require__(20);\n\t\n\tvar _unhilight_selection2 = _interopRequireDefault(_unhilight_selection);\n\t\n\tvar _add_mouse_events = __webpack_require__(14);\n\t\n\tvar _add_mouse_events2 = _interopRequireDefault(_add_mouse_events);\n\t\n\tvar _init_riot_events = __webpack_require__(16);\n\t\n\tvar _init_riot_events2 = _interopRequireDefault(_init_riot_events);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  // event bus\n\t  getControl: function getControl() {\n\t    return riot.observable();\n\t  },\n\t  addMouseEvents: _add_mouse_events2.default,\n\t  initRiotEvents: _init_riot_events2.default,\n\t\n\t  // legend\n\t  getLegendItems: _get_legend_items2.default,\n\t  getLegendTemplates: _get_legend_template2.default,\n\t  mountLegend: function mountLegend(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-legend',\n\t      riotSelector: opts.element,\n\t      cssClass: 'legend',\n\t      opts: {\n\t        legendItems: C.legendItems,\n\t        templates: C.legendTemplates\n\t      }\n\t    });\n\t  },\n\t\n\t  // infobox\n\t  getInfoboxTemplate: _get_infobox_template2.default,\n\t  mountInfobox: function mountInfobox(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-infobox',\n\t      riotSelector: opts.element,\n\t      cssClass: 'infobox',\n\t      opts: {\n\t        control: C.control,\n\t        template: C.infoboxTemplate\n\t      }\n\t    });\n\t  },\n\t\n\t  // data selector\n\t  getSelectorData: _get_selector_data2.default,\n\t  mountSelector: function mountSelector(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-selector',\n\t      riotSelector: opts.element,\n\t      cssClass: 'selector',\n\t      opts: {\n\t        getLabel: opts.getLabel ? opts.getLabel : function (d) {\n\t          return d[C.xCol];\n\t        },\n\t        control: C.control,\n\t        data: C.selectorData,\n\t        hilight: C.hilight\n\t      }\n\t    });\n\t  },\n\t\n\t  // hilighting\n\t  findSelectionForHilight: _find_selection2.default,\n\t  hilightSelection: _hilight_selection2.default,\n\t  unhilightSelection: _unhilight_selection2.default\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  init: {\n\t    control: 'getControl',\n\t    _events: 'initRiotEvents'\n\t  },\n\t  draw: {\n\t    _events: 'addMouseEvents'\n\t  },\n\t  legend: {\n\t    legendItems: 'getLegendItems',\n\t    legendTemplates: 'getLegendTemplates',\n\t    legendEl: 'mountLegend'\n\t  },\n\t  infobox: {\n\t    infoboxTemplate: 'getInfoboxTemplate',\n\t    infoboxEl: 'mountInfobox'\n\t  },\n\t  selector: {\n\t    selectorData: 'getSelectorData',\n\t    selectorEl: 'mountSelector'\n\t  },\n\t  hilight: {\n\t    _unhilight: 'unhilightSelection',\n\t    hilightedSel: 'findSelectionForHilight',\n\t    _hilight: 'hilightSelection'\n\t  },\n\t  unhilight: {\n\t    hilightedSel: 'unhilightSelection'\n\t  }\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _immutable = __webpack_require__(28);\n\t\n\tvar _plays = __webpack_require__(11);\n\t\n\tvar _plays2 = _interopRequireDefault(_plays);\n\t\n\tvar _defaults = __webpack_require__(10);\n\t\n\tvar _defaults2 = _interopRequireDefault(_defaults);\n\t\n\tvar _template = __webpack_require__(12);\n\t\n\tvar _template2 = _interopRequireDefault(_template);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// update plays & defaults\n\tvar update = (0, _immutable.fromJS)(d3.playbooks.CHARTS.baseChart).mergeDeep({ plays: _plays2.default, defaults: _defaults2.default });\n\td3.playbooks.CHARTS.baseChart = update.toJS();\n\t\n\t// update playbook template\n\td3.playbooks.TEMPLATE = d3.playbooks.TEMPLATE.mergeDeep(_template2.default);\n\t\n\tvar publics = d3.playbooks.PUBLIC_METHODS.concat(['legend', 'infobox', 'selector', 'hilight', 'unhilight']);\n\td3.playbooks.PUBLIC_METHODS = publics;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (_ref) {\n\t  var drawedSelection = _ref.drawedSelection,\n\t      control = _ref.control;\n\t\n\t  drawedSelection.on('mouseover', function (data) {\n\t    control.trigger(riot.EVT.mouseover, {\n\t      node: this,\n\t      data: data\n\t    });\n\t  });\n\t  drawedSelection.on('mouseout', function (data) {\n\t    control.trigger(riot.EVT.mouseout, {\n\t      node: this,\n\t      data: data\n\t    });\n\t  });\n\t  // if (clearSvg) {\n\t  // for mobile devices: open tooltip on click,\n\t  // but only if it's possible to clear it afterwards\n\t  // (that's what the `clearSvg` flag is for)\n\t  // FIXME: this obviously crashes with the `clearSvg` click event\n\t  // drawedSelection\n\t  //   .on('touchstart', d => {\n\t  //     control.trigger(riot.EVT.hilight, d)\n\t  //   })\n\t  // }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t// event names\n\triot.EVT = {\n\t  mouseover: 'mouseover',\n\t  mouseout: 'mouseout',\n\t  updateInfobox: 'update_infobox',\n\t  emptyInfobox: 'empty_infobox',\n\t  updateSelector: 'update_selector'\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (chart) {\n\t  chart.control.on(riot.EVT.mouseover, function (_ref) {\n\t    var node = _ref.node,\n\t        data = _ref.data;\n\t\n\t    chart.hilightedSel ? chart.unhilight(chart) : null;\n\t    chart.hilightNode(node);\n\t    chart.control.trigger(riot.EVT.updateInfobox, data);\n\t    chart.control.trigger(riot.EVT.updateSelector, data);\n\t  });\n\t\n\t  chart.control.on(riot.EVT.mouseout, function (_ref2) {\n\t    var node = _ref2.node,\n\t        data = _ref2.data;\n\t\n\t    chart.unhilightNode(node);\n\t    chart.control.trigger(riot.EVT.emptyInfobox);\n\t  });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// find selection based on data\n\t// can act as public function, gets `C` object\n\t//\n\t// @param data str || object\n\t//  if str, data matching with `data` === `d[xCol]`\n\t//  else complete object matching (data === d)\n\t//\n\t// https://github.com/d3/d3-selection/blob/master/README.md#selection_select\n\t//\n\texports.default = function (_ref, data) {\n\t  var drawedSelection = _ref.drawedSelection,\n\t      xCol = _ref.xCol;\n\t\n\t  var match = void 0;\n\t  if (typeof data === 'string') match = function match(d) {\n\t    return data === d[xCol];\n\t  };else match = function match(d) {\n\t    return data === d;\n\t  };\n\t\n\t  return drawedSelection.select(function (d, i) {\n\t    return match(d) ? this : null;\n\t  });\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _hilight_node = __webpack_require__(4);\n\t\n\tvar _hilight_node2 = _interopRequireDefault(_hilight_node);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (_ref) {\n\t  var hilightedSel = _ref.hilightedSel;\n\t  return (0, _hilight_node2.default)(hilightedSel.node());\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (node) {\n\t  return node.classList.remove('-hilight');\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (_ref) {\n\t  var hilightedSel = _ref.hilightedSel;\n\t\n\t  hilightedSel ? hilightedSel.classed('-hilight', false) : null;\n\t  return null;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DEFAULT_TEMPLATE = '\\n  <dl class=\"d3-playbooks__infobox-table\">\\n    <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{xCol}\">{xCol}</dt>\\n    <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{xCol}\">{xVar}</dd>\\n    {yDt}\\n  </dl>\\n';\n\t\n\tvar YCOL_TEMPLATE = '\\n  <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{yCol}\">{yCol}</dt>\\n  <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{yCol}\">{yVar}</dd>\\n';\n\t\n\tvar varTmpl = function varTmpl(_var) {\n\t  return '{' + _var + '}';\n\t};\n\tvar getYColTemplate = function getYColTemplate(yCol) {\n\t  return (0, _stringTemplate2.default)(YCOL_TEMPLATE, { yCol: yCol, yVar: varTmpl(yCol) });\n\t};\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var xCol = _ref.xCol,\n\t      yCol = _ref.yCol,\n\t      yCols = _ref.yCols;\n\t  var template = _ref2.template;\n\t\n\t  return template ? template : (0, _stringTemplate2.default)(DEFAULT_TEMPLATE, {\n\t    xCol: xCol,\n\t    xVar: varTmpl(xCol),\n\t    yDt: yCols ? yCols.map(function (yCol) {\n\t      return getYColTemplate(yCol);\n\t    }).join('') : getYColTemplate(yCol)\n\t  });\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var groupCol = _ref.groupCol,\n\t      data = _ref.data,\n\t      yCol = _ref.yCol,\n\t      yCols = _ref.yCols,\n\t      multiData = _ref.multiData,\n\t      getColor = _ref.getColor;\n\t  var labels = _ref2.labels;\n\t\n\t  if (groupCol) {\n\t    var _ret = function () {\n\t      var groups = [];\n\t      var items = [];\n\t      data.map(function (d) {\n\t        var item = d[groupCol];\n\t        if (groups.indexOf(item) < 0) {\n\t          groups.push(item);\n\t          items.push({\n\t            label: item,\n\t            color: getColor(d)\n\t          });\n\t        }\n\t      });\n\t      return {\n\t        v: items\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n\t  } else if (yCols) {\n\t    var _ret2 = function () {\n\t      // FIXME ?\n\t      var yValues = multiData.yValues;\n\t\n\t      return {\n\t        v: yCols.map(function (c, i) {\n\t          return {\n\t            label: labels ? labels[c] : c,\n\t            color: getColor(yValues[i])\n\t          };\n\t        })\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret2 === \"undefined\" ? \"undefined\" : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t  } else if (yCol) {\n\t    return [{\n\t      label: labels ? labels[yCol] : yCol,\n\t      color: getColor(data)\n\t    }];\n\t  }\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tvar WRAPPER_TEMPLATE = '<ul class=\"d3-playbooks__legend-list\">{body}</ul>';\n\t\n\tvar ITEM_TEMPLATE = '<li class=\"d3-playbooks__legend-item\">\\n  <span style=\"background-color:{color};\"></span>{label}</li>';\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var wrapperTemplate = _ref2.wrapperTemplate,\n\t      itemTemplate = _ref2.itemTemplate;\n\t\n\t  _objectDestructuringEmpty(_ref);\n\t\n\t  return {\n\t    wrapper: wrapperTemplate || WRAPPER_TEMPLATE,\n\t    item: itemTemplate || ITEM_TEMPLATE\n\t  };\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// agnostic function for mounting of concrete riot tags\n\t// the first argument (object) is the actual chart (`C`) object\n\texports.default = function (_ref, _ref2) {\n\t  var cssNamespace = _ref.cssNamespace,\n\t      elementId = _ref.elementId,\n\t      element = _ref.element;\n\t  var tagName = _ref2.tagName,\n\t      riotSelector = _ref2.riotSelector,\n\t      cssClass = _ref2.cssClass,\n\t      _ref2$opts = _ref2.opts,\n\t      opts = _ref2$opts === undefined ? {} : _ref2$opts;\n\t\n\t  if (!elementId && !riotSelector) {\n\t    // instead of `d3-playbooks-base`, here we need actual element ids\n\t    throw new Error('need `chart.elementId` or `element` for riot components be able to be mounted');\n\t  }\n\t\n\t  var className = cssNamespace + '__' + (cssClass || tagName);\n\t\n\t  if (!riotSelector) {\n\t    riotSelector = elementId + '-' + tagName;\n\t    element.append('div').attr('id', riotSelector).attr('class', className);\n\t    riotSelector = '#' + riotSelector;\n\t  }\n\t\n\t  // add custom css class\n\t  opts.className = className;\n\t\n\t  return riot.mount(riotSelector, tagName, opts)[0];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// convert data to mapping for selector, this works only for unique (ordinal) scales\n\t//\n\t// opts:\n\t//  - getLabel: function to compute label based on chart `data`, default xCol\n\t//  - sortItems: function to sort labels, BUT based on chart `data` itself not on computed labels\n\texports.default = function (_ref, _ref2) {\n\t  var data = _ref.data,\n\t      xCol = _ref.xCol;\n\t  var getLabel = _ref2.getLabel,\n\t      sortItems = _ref2.sortItems;\n\t\n\t  var _data = {};\n\t  var getKey = function getKey(d) {\n\t    return getLabel ? getLabel(d) : d[xCol];\n\t  };\n\t  var compare = function compare(a, b) {\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t  };\n\t  var _sort = sortItems ? sortItems : function (a, b) {\n\t    return compare(getKey(a), getKey(b));\n\t  };\n\t  data.sort(_sort).map(function (d) {\n\t    return _data[getKey(d)] = d;\n\t  });\n\t  return _data;\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".d3-playbooks__infobox dl{line-height:1.4;margin:0;padding:0}.d3-playbooks__infobox-label{float:none;padding:0;margin:0;font-weight:700}.d3-playbooks__infobox-value{float:none;padding:0;margin:0 0 .4em}.d3-playbooks__infobox-table{width:250px}.d3-playbooks__infobox-table dd,.d3-playbooks__infobox-table dt{float:left;width:50%}.d3-playbooks__legend-list{padding:0;margin:0}.d3-playbooks__legend-item{list-style:none}.d3-playbooks__legend-item span{width:10px;height:10px;display:inline-block}.d3-playbooks .bar,.d3-playbooks .dot{fill-opacity:.7}.d3-playbooks .bar:hover,.d3-playbooks .dot:hover{fill-opacity:1}.d3-playbooks .bar.-hilight,.d3-playbooks .dot.-hilight{fill-opacity:1;stroke:#000;stroke-width:2px}.d3-playbooks .focus circle{fill:#4682b4;r:4}.d3-playbooks .-empty{display:none}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014-2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Immutable = factory());\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    // This implements \"is array index\" which the ECMAString spec defines as:\n\t    //\n\t    //     A String property name P is an array index if and only if\n\t    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n\t    //     to 2^32−1.\n\t    //\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n\t    if (typeof index !== 'number') {\n\t      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\t      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t        return NaN;\n\t      }\n\t      index = uint32Index;\n\t    }\n\t    return index < 0 ? ensureSize(iter) + index : index;\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && (value.constructor === Object || value.constructor === undefined);\n\t  }\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t        return true;\n\t      }\n\t      if (!valueA || !valueB) {\n\t        return false;\n\t      }\n\t    }\n\t    if (typeof valueA.equals === 'function' &&\n\t        typeof valueB.equals === 'function' &&\n\t        valueA.equals(valueB)) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        if (typeof a.cacheResult === 'function') {\n\t          a.cacheResult();\n\t        }\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.includes = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step !== 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.includes = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  var imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      if (o !== o || o === Infinity) {\n\t        return 0;\n\t      }\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    if (type === 'object') {\n\t      return hashJSObj(o);\n\t    }\n\t    if (typeof o.toString === 'function') {\n\t      return hashString(o.toString());\n\t    }\n\t    throw new Error('Value type ' + type + ' cannot be hashed.');\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash;\n\t    if (usingWeakMap) {\n\t      hash = weakMap.get(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash !== undefined) {\n\t      return hash;\n\t    }\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (usingWeakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable !== undefined &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType !== undefined) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // Get references to ES5 object methods.\n\t  var isExtensible = Object.isExtensible;\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, '@', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var usingWeakMap = typeof WeakMap === 'function';\n\t  var weakMap;\n\t  if (usingWeakMap) {\n\t    weakMap = new WeakMap();\n\t  }\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) && !isOrdered(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n\t      return emptyMap().withMutations(function(map ) {\n\t        for (var i = 0; i < keyValues.length; i += 2) {\n\t          if (i + 1 >= keyValues.length) {\n\t            throw new Error('Missing value for key: ' + keyValues[i]);\n\t          }\n\t          map.set(keyValues[i], keyValues[i + 1]);\n\t        }\n\t      });\n\t    };\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.merge === 'function' ?\n\t          m.merge.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.mergeDeep === 'function' ?\n\t          m.mergeDeep.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(existing, value, key) {\n\t    return existing && existing.mergeDeep && isIterable(value) ?\n\t      existing.mergeDeep(value) :\n\t      is(existing, value) ? existing : value;\n\t  }\n\t\n\t  function deepMergerWith(merger) {\n\t    return function(existing, value, key)  {\n\t      if (existing && existing.mergeDeepWith && isIterable(value)) {\n\t        return existing.mergeDeepWith(merger, value);\n\t      }\n\t      var nextValue = merger(existing, value, key);\n\t      return is(existing, nextValue) ? existing : nextValue;\n\t    };\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value, key)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index >= 0 && index < this.size) {\n\t        index += this._origin;\n\t        var node = listNodeFor(this, index);\n\t        return node && node.array[index & MASK];\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.insert = function(index, value) {\n\t      return this.splice(index, 0, value);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t          return this;\n\t        }\n\t      }\n\t\n\t      var editable = editableVNode(this, ownerID);\n\t      editable.array.splice(sizeIndex + 1);\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index !== index) {\n\t      return list;\n\t    }\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      end = end | 0;\n\t    }\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might need creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might need creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.includes = function(value) {\n\t      return this._iter.includes(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.includes(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          var indexedIterable = isIterable(entry);\n\t          return fn(\n\t            indexedIterable ? entry.get(1) : entry[1],\n\t            indexedIterable ? entry.get(0) : entry[0],\n\t            this$0\n\t          );\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            var indexedIterable = isIterable(entry);\n\t            return iteratorValue(\n\t              type,\n\t              indexedIterable ? entry.get(0) : entry[0],\n\t              indexedIterable ? entry.get(1) : entry[1],\n\t              step\n\t            );\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.includes(key)};\n\t    flipSequence.includes = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      if (end === Infinity) {\n\t        end = originalSize;\n\t      } else {\n\t        end = end | 0;\n\t      }\n\t    }\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size and these do not resolve to NaN.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    // Note: resolvedEnd is undefined when the original sequence's length is\n\t    // unknown and this slice did not supply an end and should contain all\n\t    // elements after resolvedBegin.\n\t    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\t    var resolvedSize = resolvedEnd - resolvedBegin;\n\t    var sliceSize;\n\t    if (resolvedSize === resolvedSize) {\n\t      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    // If iterable.size is undefined, the size of the realized sliceSeq is\n\t    // unknown at this point unless the number of items to slice is 0\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize !== 0 && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ < resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var hasInitialized;\n\t\n\t      var RecordType = function Record(values) {\n\t        if (values instanceof RecordType) {\n\t          return values;\n\t        }\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        if (!hasInitialized) {\n\t          hasInitialized = true;\n\t          var keys = Object.keys(defaultValues);\n\t          setProps(RecordTypePrototype, keys);\n\t          RecordTypePrototype.size = keys.length;\n\t          RecordTypePrototype._name = name;\n\t          RecordTypePrototype._keys = keys;\n\t          RecordTypePrototype._defaultValues = defaultValues;\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var RecordType = this.constructor;\n\t      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      if (this._map && !this._map.has(k)) {\n\t        var defaultVal = this._defaultValues[k];\n\t        if (v === defaultVal) {\n\t          return this;\n\t        }\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name || 'Record';\n\t  }\n\t\n\t  function setProps(prototype, names) {\n\t    try {\n\t      names.forEach(setProp.bind(undefined, prototype));\n\t    } catch (error) {\n\t      // Object.defineProperty failed. Probably IE8.\n\t    }\n\t  }\n\t\n\t  function setProp(prototype, name) {\n\t    Object.defineProperty(prototype, name, {\n\t      get: function() {\n\t        return this.get(name);\n\t      },\n\t      set: function(value) {\n\t        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t        this.set(name, value);\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) && !isOrdered(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      index = wrapIndex(this, index);\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterate(fn);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterator(type);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    includes: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v.toString() : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findEntry: function(predicate, context, notSetValue) {\n\t      var found = notSetValue;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastEntry: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toKeyedSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.includes(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.toKeyedSeq().reverse().keyOf(searchValue);\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    }\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t  IterablePrototype.contains = IterablePrototype.includes;\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    }\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      var key = this.lastKeyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      // If index is negative, it should resolve relative to the size of the\n\t      // collection. However size may be expensive to compute if not cached, so\n\t      // only call count() if the number is in fact negative.\n\t      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var entry = this.findLastEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return Range(0, this.size);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    }\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    includes: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    }\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.includes;\n\t  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = imul(h, 0xCC9E2D51);\n\t    h = imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(29)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// d3-playbooks.riot-components.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 41605ce484907994cc6c","/* Riot v3.0.7, @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar ATTRS_PREFIX = 'riot-';\nvar REF_DIRECTIVES = ['data-ref', 'ref'];\nvar IS_DIRECTIVE = 'data-is';\nvar CONDITIONAL_DIRECTIVE = 'if';\nvar LOOP_DIRECTIVE = 'each';\nvar LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';\nvar SHOW_DIRECTIVE = 'show';\nvar HIDE_DIRECTIVE = 'hide';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check whether a DOM node must be considered a part of an svg document\n * @param   { String } name -\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return RE_SVG_TAGS.test(name)\n}\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisSVGTag: isSVGTag,\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML)\n    { return el.outerHTML }\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: mkEl,\n\tgetOuterHTML: getOuterHTML,\n\tsetInnerHTML: setInnerHTML,\n\tremAttr: remAttr,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.1\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch];\n\n      recch.lastIndex = ix;\n      ix = 1;\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) { break }\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.root && ctx.root.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      if (err.riotData.tagName) {\n        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName.toLowerCase());\n      }\n      console.error(err);\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.1';\n\n  return _tmpl\n\n})();\n\nvar observable$1 = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n\n  for (var i = 0, el; i < len; ++i) {\n    el = list[i];\n    // return false -> current item was removed by fn during the loop\n    if (fn(el, i) === false)\n      { i--; }\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return ~array.indexOf(item)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar EVENTS_PREFIX_REGEX = /^on/;\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this._parent,\n    item = this._item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag._item;\n      ptag = ptag._parent;\n    } }\n\n  // override the event properties\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  if (!dom.addEventListener) {\n    dom[name] = cb;\n    return\n  }\n\n  // avoid to bind twice the same event\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\n  // cache the callback directly on the DOM node\n  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\n  if (dom._riotEvents[name])\n    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\n  dom._riotEvents[name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag } parent - parent for tag creation\n */\nfunction updateDataIs(expr, parent) {\n  var tagName = tmpl(expr.value, parent),\n    conf;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n    each(expr.attrs, function (a) { return setAttr(expr.tag.root, a.name, a.value); });\n    expr.tag.unmount(true);\n  }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  expr.tagName = tagName;\n  expr.tag.mount();\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.on('unmount', function () {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag._parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  });\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  var dom = expr.dom,\n    attrName = expr.attr,\n    isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),\n    value = tmpl(expr.expr, this),\n    isValueAttr = attrName === 'riot-value',\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    old;\n\n  if (expr.bool)\n    { value = value ? attrName : false; }\n  else if (isUndefined(value) || value === null)\n    { value = ''; }\n\n  if (expr._riot_id) { // if it's a tag\n    if (expr.isMounted) {\n      expr.update();\n\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n\n      if (isVirtual) {\n        var frag = document.createDocumentFragment();\n        makeVirtual.call(expr, frag);\n        expr.root.parentElement.replaceChild(frag, expr.root);\n      }\n    }\n    return\n  }\n\n  old = expr.value;\n  expr.value = value;\n\n  if (expr.update) {\n    expr.update();\n    return\n  }\n\n  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n  if (old === value) { return }\n  // no change, so nothing more to do\n  if (isValueAttr && dom.value === value) { return }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n  // remove original attribute\n  if (!expr.isAttrRemoved || !value) {\n    remAttr(dom, attrName);\n    expr.isAttrRemoved = true;\n  }\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    if (attrName === HIDE_DIRECTIVE) { value = !value; }\n    dom.style.display = value ? '' : 'none';\n  // field value\n  } else if (isValueAttr) {\n    dom.value = value;\n  // <img src=\"{ expr }\">\n  } else if (startsWith(attrName, ATTRS_PREFIX) && attrName !== IS_DIRECTIVE) {\n    attrName = attrName.slice(ATTRS_PREFIX.length);\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName])\n      { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n    if (value != null)\n      { setAttr(dom, attrName, value); }\n  } else {\n    // <select> <option selected={true}> </select>\n    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value) {\n      parent.value = dom.value;\n    } if (expr.bool) {\n      dom[attrName] = value;\n      if (!value) { return }\n    } if (value === 0 || value && typeof value !== T_OBJECT) {\n      setAttr(dom, attrName, value);\n    }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    remAttr(dom, CONDITIONAL_DIRECTIVE);\n    this.tag = tag;\n    this.expr = expr;\n    this.stub = document.createTextNode('');\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    var newValue = tmpl(this.expr, this.tag);\n\n    if (newValue && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n\n      this.expressions = [];\n      parseExpressions.apply(this.tag, [this.current, this.expressions, true]);\n    } else if (!newValue && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode)\n        { this.current.parentNode.removeChild(this.current); }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (newValue) { updateAllExpressions.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n    delete this.pristine;\n    delete this.parentNode;\n    delete this.stub;\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    this.firstRun = true;\n\n    return this\n  },\n  update: function update() {\n    var value = this.rawValue;\n    if (this.hasExp)\n      { value = tmpl(this.rawValue, this.parent); }\n\n    // if nothing changed, we're done\n    if (!this.firstRun && value === this.value) { return }\n\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.tag || this.dom;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\n    if (isBlank(value)) {\n      // if the value is blank, we remove it\n      remAttr(this.dom, this.attr);\n    } else {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n      // set the actual DOM attr\n      setAttr(this.dom, this.attr, value);\n    }\n    this.value = value;\n    this.firstRun = false;\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    delete this.dom;\n    delete this.parent;\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n * @param   { String } tagName - key used to identify the type of tag\n */\nfunction unmountRedundant(items, tags, tagName) {\n  var i = tags.length,\n    j = items.length,\n    t;\n\n  while (i > j) {\n    t = tags[--i];\n    tags.splice(i, 1);\n    t.unmount();\n    arrayishRemove(t.parent, tagName, t, true);\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    var tag = this$1.tags[tagName];\n    if (isArray(tag))\n      { each(tag, function (t) {\n        moveChildTag.apply(t, [tagName, i]);\n      }); }\n    else\n      { moveChildTag.apply(tag, [tagName, i]); }\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, LOOP_DIRECTIVE);\n\n  var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = RE_SPECIAL_TAGS.test(tagName),\n    parentNode = dom.parentNode,\n    ref = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(ref, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      frag = createFrag(),\n      isObject$$1 = !isArray(items),\n      root = ref.parentNode;\n\n    // object loop. any changes cause full redraw\n    if (isObject$$1) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key && !isObject$$1)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(Object.create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        isNew = !~oldPos,\n        mustAppend = i <= tags.length,\n        pos = !isNew && doReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos];\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (\n        doReorder && isNew // by default we always try to reorder the DOM elements\n        ||\n        !doReorder && !tag // with no-reorder we just update the old tags\n      ) {\n        tag = new Tag$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        pos = i; // handled here so no move\n      } else { tag.update(item); }\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && doReorder) {\n        // #closes 2040\n        if (contains(items, oldItems[i])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n        }\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item;\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent);\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags, tagName);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, ref);\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, LOOP_DIRECTIVE)) {\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes)});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      var conf = {root: dom, parent: this$1, hasImpl: true};\n      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n      return false\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n\n  return { tree: tree, root: root }\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (contains(REF_DIRECTIVES, name)) {\n      expr =  Object.create(RefExpr).init(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, checkSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  el.stub = true;\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$2(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$1(name, tmpl, css, attrs, fn) {\n  if (css)\n    { styleManager.add(css, name); }\n\n  var exists = !!__TAG_IMPL[name];\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  if (exists && util.hotReloader)\n    { util.hotReloader(name); }\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$1(selector, tagName, opts) {\n  var tags = [];\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, IS_DIRECTIVE);\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, IS_DIRECTIVE, tagName);\n      }\n\n      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag$$1)\n        { tags.push(tag$$1); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  var elem;\n  var allTags;\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar _id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$1((\"__unnamed_\" + (_id++)), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error('Unregistered mixin: ' + name) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n}\n\nfunction unregister$1(name) {\n  delete __TAG_IMPL[name];\n}\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$1(impl, conf, innerHTML) {\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = conf.isAnonymous,\n    item = cleanUpData(conf.item),\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  observable$1(this);\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n  root.isLoop = isLoop;\n\n  defineProperty(this, '_internal', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\n  extend(this, { root: root, opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'parent', parent || null);\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n    if (this.isMounted) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (this.isMounted) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance,\n        props = [],\n        obj;\n\n      mix = isString(mix) ? mixin$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (key !== 'init') {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // children in loop should inherit from true parent\n    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$1(GLOBAL_MIXIN);\n\n    if (globalMixin) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    this.trigger('before-mount');\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, false]);\n\n    this.update(item);\n\n    if (isLoop && isAnonymous) {\n      // update the root attribute for the looped elements\n      this.root = root = dom.firstChild;\n    } else {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n      if (root.stub) { root = parent.root; }\n    }\n\n    defineProperty(this, 'root', root);\n    this.isMounted = true;\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent || this.parent.isMounted) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else { this.parent.one('mount', function () {\n      this$1.trigger('mount');\n    }); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    this.trigger('before-unmount');\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n      remAttr(root, name);\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n          if(parent !== ptag) // remove from _parent too\n            { arrayishRemove(parent.tags, tagName, this); }\n        }\n      } else {\n        while (el.firstChild) { el.removeChild(el.firstChild); }\n      }\n\n      if (!mustKeepRoot) {\n        p.removeChild(el);\n      } else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, IS_DIRECTIVE);\n      }\n    }\n\n    if (this._internal.virts) {\n      each(this._internal.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    this.trigger('unmount');\n    this.off('*');\n    this.isMounted = false;\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) ||\n    getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = '';\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag._internal.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$1) { expr.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger)))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n */\nfunction arrayishAdd(obj, key, value, ensureArray) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else if (!isArr || isArr && !contains(dest, value)) {\n    if (isArr) { dest.push(value); }\n    else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    each(obj[key], function(item, i) {\n      if (item === value) { obj[key].splice(i, 1); }\n    });\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub)\n      { return true }\n    dom = dom.parentNode;\n  }\n  return false\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  // clear the inner html\n  root.innerHTML = '';\n\n  var conf = { root: root, opts: opts };\n  if (opts && opts.parent) { conf.parent = opts.parent; }\n\n  if (impl && root) { Tag$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n  this._internal.tail = this.root.appendChild(tail);\n\n  el = this._internal.head;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1._internal.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target._internal.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this._internal.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1._internal.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target._internal.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tisInStub: isInStub,\n\tmountTo: mountTo,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\nvar settings = Object.create(brackets.settings);\n\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$$1 = Tag$2;\nvar tag$$1 = tag$1;\nvar tag2$$1 = tag2$1;\nvar mount$$1 = mount$1;\nvar mixin$$1 = mixin$1;\nvar update$$1 = update$1;\nvar unregister$$1 = unregister$1;\nvar observable = observable$1;\n\nvar riot$1 = {\n  settings: settings,\n  util: util,\n  // core\n  Tag: Tag$$1,\n  tag: tag$$1,\n  tag2: tag2$$1,\n  mount: mount$$1,\n  mixin: mixin$$1,\n  update: update$$1,\n  unregister: unregister$$1,\n  observable: observable\n};\n\nexports.settings = settings;\nexports.util = util;\nexports.Tag = Tag$$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$$1;\nexports.unregister = unregister$$1;\nexports.observable = observable;\nexports['default'] = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot/riot.js\n// module id = 1\n// module chunks = 0","var nargs = /\\{([0-9a-zA-Z_]+)\\}/g\n\nmodule.exports = template\n\nfunction template(string) {\n    var args\n\n    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\n        args = arguments[1]\n    } else {\n        args = new Array(arguments.length - 1)\n        for (var i = 1; i < arguments.length; ++i) {\n            args[i - 1] = arguments[i]\n        }\n    }\n\n    if (!args || !args.hasOwnProperty) {\n        args = {}\n    }\n\n    return string.replace(nargs, function replaceArg(match, i, index) {\n        var result\n\n        if (string[index - 1] === \"{\" &&\n            string[index + match.length] === \"}\") {\n            return i\n        } else {\n            result = args.hasOwnProperty(i) ? args[i] : null\n            if (result === null || result === undefined) {\n                return \"\"\n            }\n\n            return result\n        }\n    })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/string-template/index.js\n// module id = 2\n// module chunks = 0","riot.tag2('raw-html', '', '', '', function(opts) {\n  this.updateContent = () => {\n    this.root.innerHTML = this.opts.content\n  }\n\n  this.on('update', () => {\n    this.updateContent()\n  })\n\n  this.updateContent()\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/raw_html.tag","export default node => {\n  node.classList.add('-hilight')\n  node.parentNode.appendChild(node)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/hilight_node.js","import render from 'string-template'\n\nimport './raw_html.tag'\n\nriot.tag2('riot-infobox', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"{opts.className} d3-playbooks__infobox {-empty: empty}\"', function(opts) {\n\n  this.empty = true\n\n  this.opts.control.on(riot.EVT.updateInfobox, data => {\n    this.update({\n      empty: false,\n      rawContent: render(this.opts.template, data)\n    })\n  })\n\n  this.opts.control.on(riot.EVT.emptyInfobox, () => {\n    this.update({empty: true})\n  })\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/infobox.tag","import render from 'string-template'\n\nimport './raw_html.tag'\n\nriot.tag2('riot-legend', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"{opts.className} d3-playbooks__legend\"', function(opts) {\n\n  this.rawContent = render(this.opts.templates.wrapper, {\n    body: this.opts.legendItems.map(l => render(this.opts.templates.item, l)).join('')\n  })\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/legend.tag","riot.tag2('riot-selector', '<select onchange=\"{hilight}\"> <option each=\"{label, i in labels}\" riot-value=\"{i}\" selected=\"{active === i}\">{label}</option> </select>', '', 'class=\"{opts.className} d3-playbooks__selector\"', function(opts) {\n\n  this.active = 0\n  this.data = this.opts.data\n  this.labels = Object.keys(this.data)\n\n  this.hilight = e => {\n    const label = this.labels[e.target.value]\n    const data = this.data[label]\n    this.opts.hilight(data)\n    this.opts.control.trigger(riot.EVT.updateInfobox, data)\n  }\n\n  this.opts.control.on(riot.EVT.updateSelector, data => {\n    const active = this.labels.indexOf(this.opts.getLabel(data))\n    this.update({active})\n  })\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/selector.tag","// render some base examples\nexport default () => {\n\n  const chart = d3.playbooks.barChart({\n    elementId: 'chart1',\n    data: [\n      ['a', 'c', 'b'],\n      ['1', 3, '2']\n    ],\n  }).render().legend({\n    wrapperTemplate: '<h3>Legend</h3><p>{body}</p>',\n    itemTemplate: 'The color for <strong>{label}</strong> is <em>{color}</em>.'\n  }).infobox({\n    element: '#my-infobox',\n    template: '<p><strong>Value for {x}:</strong> {y}</p>'\n  }).selector({\n    getLabel: d => d.x + ' (' + d.y + ')',\n    sortItems: (a, b) => b.y - a.y\n  })\n\n  d3.playbooks.scatterChart({\n    elementId: 'chart2',\n    data: {\n      x: [1, 2, 3, 4, 6],\n      y: [2, 5, 1, 1, 8]\n    },\n    color: d3.schemeCategory10,\n    getLegendItems: C => {\n      return C.data.map(d => {\n        return {\n          label: 'Item ' + d.x,\n          color: C.getColor(d)\n        }\n      })\n    }\n  }).render().legend().infobox().selector()\n\n  d3.playbooks.multiLineChart({\n    elementId: 'chart3',\n    dataUrl: 'data/multiline.csv',\n    yCols: ['y1', 'y2', 'y3']\n  }).render().infobox()\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/examples.js","// available components\nimport './components/legend.tag'\nimport './components/infobox.tag'\nimport './components/selector.tag'\n\n// event handling\nimport './utils/events/event_names.js'\n\n// additional stzle\nimport './styles/main.scss'\n\n// exported stuff\nimport './public.js'\n\n// dev mode\nimport renderExamples from './examples.js'\n\nif (process.env.NODE_ENV == 'development') {\n  renderExamples()\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import hilightNode from '../utils/hilight/hilight_node.js'\nimport unhilightNode from '../utils/hilight/unhilight_node.js'\n\nexport default {\n  control: null,\n  hilightNode,\n  unhilightNode\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/defaults.js","import mountRiotTag from '../utils/mount_riot_tag.js'\nimport getLegendItems from '../utils/legend/get_legend_items.js'\nimport getLegendTemplates from '../utils/legend/get_legend_template.js'\nimport getInfoboxTemplate from '../utils/infobox/get_infobox_template.js'\nimport getSelectorData from '../utils/selector/get_selector_data.js'\nimport findSelectionForHilight from '../utils/hilight/find_selection.js'\nimport hilightSelection from '../utils/hilight/hilight_selection.js'\nimport unhilightSelection from '../utils/hilight/unhilight_selection.js'\nimport addMouseEvents from '../utils/events/add_mouse_events.js'\nimport initRiotEvents from '../utils/events/init_riot_events.js'\n\nexport default {\n  // event bus\n  getControl: () => riot.observable(),\n  addMouseEvents,\n  initRiotEvents,\n\n  // legend\n  getLegendItems,\n  getLegendTemplates,\n  mountLegend: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-legend',\n    riotSelector: opts.element,\n    cssClass: 'legend',\n    opts: {\n      legendItems: C.legendItems,\n      templates: C.legendTemplates\n    }\n  }),\n\n  // infobox\n  getInfoboxTemplate,\n  mountInfobox: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-infobox',\n    riotSelector: opts.element,\n    cssClass: 'infobox',\n    opts: {\n      control: C.control,\n      template: C.infoboxTemplate\n    }\n  }),\n\n  // data selector\n  getSelectorData,\n  mountSelector: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-selector',\n    riotSelector: opts.element,\n    cssClass: 'selector',\n    opts: {\n      getLabel: opts.getLabel ? opts.getLabel : d => d[C.xCol],\n      control: C.control,\n      data: C.selectorData,\n      hilight: C.hilight\n    }\n  }),\n\n  // hilighting\n  findSelectionForHilight,\n  hilightSelection,\n  unhilightSelection\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/plays.js","export default {\n  init: {\n    control: 'getControl',\n    _events: 'initRiotEvents'\n  },\n  draw: {\n    _events: 'addMouseEvents',\n  },\n  legend: {\n    legendItems: 'getLegendItems',\n    legendTemplates: 'getLegendTemplates',\n    legendEl: 'mountLegend'\n  },\n  infobox: {\n    infoboxTemplate: 'getInfoboxTemplate',\n    infoboxEl: 'mountInfobox'\n  },\n  selector: {\n    selectorData: 'getSelectorData',\n    selectorEl: 'mountSelector'\n  },\n  hilight: {\n    _unhilight: 'unhilightSelection',\n    hilightedSel: 'findSelectionForHilight',\n    _hilight: 'hilightSelection'\n  },\n  unhilight: {\n    hilightedSel: 'unhilightSelection'\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/template.js","import {fromJS as _} from 'immutable'\nimport plays from './playbooks/plays.js'\nimport defaults from './playbooks/defaults.js'\nimport template from './playbooks/template.js'\n\n// update plays & defaults\nconst update = _(d3.playbooks.CHARTS.baseChart).mergeDeep({plays, defaults})\nd3.playbooks.CHARTS.baseChart = update.toJS()\n\n// update playbook template\nd3.playbooks.TEMPLATE = d3.playbooks.TEMPLATE.mergeDeep(template)\n\nconst publics = d3.playbooks.PUBLIC_METHODS.concat(['legend', 'infobox', 'selector', 'hilight', 'unhilight'])\nd3.playbooks.PUBLIC_METHODS = publics\n\n\n\n// WEBPACK FOOTER //\n// ./src/public.js","export default ({\n  drawedSelection,\n  control,\n  // clearSvg\n}) => {\n  drawedSelection\n    .on('mouseover', function(data) {\n      control.trigger(riot.EVT.mouseover, {\n        node: this,\n        data\n      })\n    })\n  drawedSelection\n    .on('mouseout', function(data) {\n      control.trigger(riot.EVT.mouseout, {\n        node: this,\n        data\n      })\n    })\n  // if (clearSvg) {\n    // for mobile devices: open tooltip on click,\n    // but only if it's possible to clear it afterwards\n    // (that's what the `clearSvg` flag is for)\n    // FIXME: this obviously crashes with the `clearSvg` click event\n    // drawedSelection\n    //   .on('touchstart', d => {\n    //     control.trigger(riot.EVT.hilight, d)\n    //   })\n  // }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/add_mouse_events.js","// event names\nriot.EVT = {\n  mouseover: 'mouseover',\n  mouseout: 'mouseout',\n  updateInfobox: 'update_infobox',\n  emptyInfobox: 'empty_infobox',\n  updateSelector: 'update_selector',\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/event_names.js","export default chart => {\n  chart.control.on(riot.EVT.mouseover, ({node, data}) => {\n    chart.hilightedSel ? chart.unhilight(chart) : null\n    chart.hilightNode(node)\n    chart.control.trigger(riot.EVT.updateInfobox, data)\n    chart.control.trigger(riot.EVT.updateSelector, data)\n  })\n\n  chart.control.on(riot.EVT.mouseout, ({node, data}) => {\n    chart.unhilightNode(node)\n    chart.control.trigger(riot.EVT.emptyInfobox)\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/init_riot_events.js","// find selection based on data\n// can act as public function, gets `C` object\n//\n// @param data str || object\n//  if str, data matching with `data` === `d[xCol]`\n//  else complete object matching (data === d)\n//\n// https://github.com/d3/d3-selection/blob/master/README.md#selection_select\n//\nexport default ({\n  drawedSelection,\n  xCol\n}, data) => {\n  let match\n  if (typeof data === 'string') match = d => data === d[xCol]\n  else match = d => data === d\n\n  return drawedSelection.select(function(d, i) {\n    return match(d) ? this : null\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/find_selection.js","import hilightNode from './hilight_node.js'\n\nexport default ({hilightedSel}) => hilightNode(hilightedSel.node())\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/hilight_selection.js","export default node => node.classList.remove('-hilight')\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/unhilight_node.js","export default ({hilightedSel}) => {\n  hilightedSel ? hilightedSel.classed('-hilight', false) : null\n  return null\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/unhilight_selection.js","import getTemplate from 'string-template'\n\nconst DEFAULT_TEMPLATE = `\n  <dl class=\"d3-playbooks__infobox-table\">\n    <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{xCol}\">{xCol}</dt>\n    <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{xCol}\">{xVar}</dd>\n    {yDt}\n  </dl>\n`\n\nconst YCOL_TEMPLATE = `\n  <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{yCol}\">{yCol}</dt>\n  <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{yCol}\">{yVar}</dd>\n`\n\nconst varTmpl = _var => '{' + _var + '}'\nconst getYColTemplate = yCol => getTemplate(YCOL_TEMPLATE, {yCol, yVar: varTmpl(yCol)})\n\nexport default ({\n  xCol,\n  yCol,\n  yCols\n}, {template}) => {\n  return template ? template :\n    getTemplate(DEFAULT_TEMPLATE, {\n        xCol: xCol,\n        xVar: varTmpl(xCol),\n        yDt: yCols ? yCols.map(yCol => getYColTemplate(yCol)).join('') : getYColTemplate(yCol)\n    })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/infobox/get_infobox_template.js","export default ({\n  groupCol,\n  data,\n  yCol,\n  yCols,\n  multiData,\n  getColor\n}, {labels}) => {\n  if (groupCol) {\n    let groups = []\n    let items = []\n    data.map(d => {\n      let item = d[groupCol]\n      if (groups.indexOf(item) < 0) {\n        groups.push(item)\n        items.push({\n          label: item,\n          color: getColor(d)\n        })\n      }\n    })\n    return items\n  } else if (yCols) {\n    // FIXME ?\n    let {yValues} = multiData\n    return yCols.map((c, i) => {\n      return {\n        label: labels ? labels[c] : c,\n        color: getColor(yValues[i])\n      }\n    })\n  } else if (yCol) {\n    return [{\n      label: labels ? labels[yCol] : yCol,\n      color: getColor(data)\n    }]\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/legend/get_legend_items.js","const WRAPPER_TEMPLATE = '<ul class=\"d3-playbooks__legend-list\">{body}</ul>'\n\nconst ITEM_TEMPLATE = `<li class=\"d3-playbooks__legend-item\">\n  <span style=\"background-color:{color};\"></span>{label}</li>`\n\nexport default ({}, {\n  wrapperTemplate,\n  itemTemplate\n}) => {\n  return {\n    wrapper: wrapperTemplate || WRAPPER_TEMPLATE,\n    item: itemTemplate || ITEM_TEMPLATE\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/legend/get_legend_template.js","// agnostic function for mounting of concrete riot tags\n// the first argument (object) is the actual chart (`C`) object\nexport default ({\n  cssNamespace,\n  elementId,\n  element\n}, {\n  tagName,        // riot tag name identifier as exported in component's `.tag` file\n  riotSelector,   // optional dom element selector (must be present), otherwise append to `element`\n  cssClass,       // optional css name to append to `C.cssNamespace + '__'`\n  opts={}         // optional opts given to tag initialization\n}) => {\n  if (!elementId && !riotSelector) {\n    // instead of `d3-playbooks-base`, here we need actual element ids\n    throw new Error('need `chart.elementId` or `element` for riot components be able to be mounted')\n  }\n\n  const className = cssNamespace + '__' + (cssClass || tagName)\n\n  if (!riotSelector) {\n    riotSelector = elementId + '-' + tagName\n    element\n      .append('div')\n      .attr('id', riotSelector)\n      .attr('class', className)\n    riotSelector = '#' + riotSelector\n  }\n\n  // add custom css class\n  opts.className = className\n\n  return riot.mount(riotSelector, tagName, opts)[0]\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/mount_riot_tag.js","// convert data to mapping for selector, this works only for unique (ordinal) scales\n//\n// opts:\n//  - getLabel: function to compute label based on chart `data`, default xCol\n//  - sortItems: function to sort labels, BUT based on chart `data` itself not on computed labels\nexport default ({\n  data,\n  xCol\n}, {\n  getLabel,\n  sortItems\n}) => {\n  const _data = {}\n  const getKey = d => getLabel ? getLabel(d) : d[xCol]\n  const compare = (a, b) => a < b ? -1 : a > b ? 1 : 0\n  const _sort = sortItems ? sortItems : (a, b) => compare(getKey(a), getKey(b))\n  data.sort(_sort).map(d => _data[getKey(d)] = d)\n  return _data\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/selector/get_selector_data.js","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".d3-playbooks__infobox dl{line-height:1.4;margin:0;padding:0}.d3-playbooks__infobox-label{float:none;padding:0;margin:0;font-weight:700}.d3-playbooks__infobox-value{float:none;padding:0;margin:0 0 .4em}.d3-playbooks__infobox-table{width:250px}.d3-playbooks__infobox-table dd,.d3-playbooks__infobox-table dt{float:left;width:50%}.d3-playbooks__legend-list{padding:0;margin:0}.d3-playbooks__legend-item{list-style:none}.d3-playbooks__legend-item span{width:10px;height:10px;display:inline-block}.d3-playbooks .bar,.d3-playbooks .dot{fill-opacity:.7}.d3-playbooks .bar:hover,.d3-playbooks .dot:hover{fill-opacity:1}.d3-playbooks .bar.-hilight,.d3-playbooks .dot.-hilight{fill-opacity:1;stroke:#000;stroke-width:2px}.d3-playbooks .focus circle{fill:#4682b4;r:4}.d3-playbooks .-empty{display:none}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader!./src/styles/main.scss\n// module id = 26\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 27\n// module chunks = 0","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable/dist/immutable.js\n// module id = 28\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 29\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/styles/main.scss\n// module id = 30\n// module chunks = 0"],"sourceRoot":""}