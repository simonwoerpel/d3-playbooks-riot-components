{"version":3,"sources":["webpack:///d3-playbooks.riot-components.min.js","webpack:///webpack/bootstrap 74437a8583232f15ebba","webpack:///./~/riot/riot.js","webpack:///./~/string-template/index.js","webpack:///./src/components/raw_html.tag","webpack:///./src/components/infobox.tag","webpack:///./src/components/legend.tag","webpack:///./src/components/selector.tag","webpack:///./src/examples.js","webpack:///./src/main.js","webpack:///./src/playbooks/defaults.js","webpack:///./src/playbooks/plays.js","webpack:///./src/playbooks/template.js","webpack:///./src/public.js","webpack:///./src/utils/events/add_mouse_events.js","webpack:///./src/utils/events/event_names.js","webpack:///./src/utils/events/init_riot_events.js","webpack:///./src/utils/hilight/find_selection.js","webpack:///./src/utils/hilight/hilight_node.js","webpack:///./src/utils/hilight/hilight_selection.js","webpack:///./src/utils/hilight/unhilight_node.js","webpack:///./src/utils/hilight/unhilight_selection.js","webpack:///./src/utils/infobox/get_infobox_template.js","webpack:///./src/utils/legend/get_legend_items.js","webpack:///./src/utils/legend/get_legend_template.js","webpack:///./src/utils/mount_riot_tag.js","webpack:///./src/utils/selector/get_selector_data.js","webpack:///./src/styles/main.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/immutable/dist/immutable.js","webpack:///./~/style-loader/addStyles.js","webpack:///./src/styles/main.scss?dd28"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","riot","global","factory","this","isSVGTag","name","RE_SVG_TAGS","test","isBoolAttr","value","RE_BOOL_ATTRS","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","obj","key","descriptor","Object","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","mkEl","isSvg","createElementNS","createElement","getOuterHTML","el","outerHTML","container","appendChild","cloneNode","innerHTML","setInnerHTML","html","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","remAttr","dom","removeAttribute","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","list","len","length","i","contains","array","item","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","slice","defineProperty","options","extend","enumerable","configurable","src","args","arguments","handleEvent","handler","e","ptag","_parent","_item","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","addEventListener","EVENTS_PREFIX_REGEX","_riotEvents","removeEventListener","updateDataIs","expr","parent","conf","tagName","tmpl","delName","tags","RIOT_TAG_IS","arrayishRemove","impl","__TAG_IMPL","hasImpl","initChildTag","mount","on","opts","dataIs","_tags","unmount","updateExpression","old","attrName","attr","isToggle","isValueAttr","isVirtual","bool","_riot_id","frag","makeVirtual","parentElement","replaceChild","isRtag","IE_VERSION","nodeValue","isAttrRemoved","style","display","RIOT_PREFIX","CASE_SENSITIVE_ATTRIBUTES","updateAllExpressions","expressions","mkitem","base","create","pos","unmountRedundant","items","t","j","splice","moveNestedTags","this$1","keys","moveChildTag","apply","move","nextTag","moveVirtual","insert","append","_each","hasKeys","mustReorder","getTagName","useRoot","RE_SPECIAL_TAGS","ref","child","getTag","ifExpr","oldItems","isLoop","isAnonymous","loopKeys","removeChild","map","filter","_mustReorder","oldPos","mustAppend","Tag$$1","arrayishAdd","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","push","IfExpr","init","parseAttributes","attributes","attrs","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","checkSvg","match","GENERIC","tblTags","stub","Tag$1","css","onCreate","tag$$1","class","constructor","mountTo","styleManager","inject","add","tag2$$1","exists","util","hotReloader","mount$$1","pushTagsTo","riotTag","elem","allTags","selectTags","split","nodeList","_el","mixin$$1","mix","g","_id","store","globals","mixins","Error","prototype","update$1","__TAGS_CACHE","unregister$$1","updateOpts","instAttrs","cleanUpData","implAttrs","propsInSyncWithParent","observable","_tag","virts","tail","head","__uid","data","shouldUpdate","inheritFrom","trigger","instance","props","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","get","set","hasOwnProperty","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","_internal","unmountAll","a","off","mustSync","newPos","skipDataIs","namedTag","o","ensureArray","dest","isArr","isInStub","inStub","implClass","_innerHTML","sib","reduce","styleNode","cssTextProp","WIN","window","undefined","RE_SPECIAL_TAGS_NO_OPTION","viewbox","documentMode","check","freeze","byName","remainder","needsInject","newNode","userNode","getElementsByTagName","styleSheet","join","cssText","brackets","UNDEF","_loopback","re","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","s","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","start","index","settings","_tmpl","_logErr","err","riotData","errorHandler","console","error","_getTmpl","Function","qstr","RE_DQUOTE","_parseExpr","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","String","fromCharCode","version","misc","callbacks","defineProperties","event","fns","arguments$1","arglen","parentTag","pristine","newValue","current","attrValue","rawValue","hasExp","firstRun","customParent","tagOrDom","refs","tr","th","td","col","vdom","Tag","tag2","unregister","template","string","nargs","result","_this","updateContent","content","_interopRequireDefault","__esModule","default","_stringTemplate","_stringTemplate2","empty","control","EVT","updateInfobox","rawContent","emptyInfobox","templates","wrapper","body","legendItems","l","active","labels","hilight","label","updateSelector","getLabel","d3","playbooks","barChart","elementId","render","legend","wrapperTemplate","itemTemplate","infobox","element","d","x","y","sortItems","scatterChart","color","schemeCategory10","getLegendItems","C","getColor","multiLineChart","dataUrl","yCols","_examples","_hilight_node","_hilight_node2","_unhilight_node","_unhilight_node2","hilightNode","unhilightNode","_mount_riot_tag","_mount_riot_tag2","_get_legend_items","_get_legend_items2","_get_legend_template","_get_legend_template2","_get_infobox_template","_get_infobox_template2","_get_selector_data","_get_selector_data2","_find_selection","_find_selection2","_hilight_selection","_hilight_selection2","_unhilight_selection","_unhilight_selection2","_add_mouse_events","_add_mouse_events2","_init_riot_events","_init_riot_events2","getControl","addMouseEvents","initRiotEvents","getLegendTemplates","mountLegend","riotSelector","cssClass","legendTemplates","getInfoboxTemplate","mountInfobox","infoboxTemplate","getSelectorData","mountSelector","xCol","selectorData","findSelectionForHilight","hilightSelection","unhilightSelection","_events","draw","legendEl","infoboxEl","selectorEl","_unhilight","hilightedSel","_hilight","unhilight","_immutable","_plays","_plays2","_defaults","_defaults2","_template","_template2","fromJS","CHARTS","baseChart","mergeDeep","plays","defaults","toJS","TEMPLATE","publics","PUBLIC_METHODS","_ref","drawedSelection","mouseover","mouseout","chart","_ref2","classList","classed","remove","DEFAULT_TEMPLATE","YCOL_TEMPLATE","varTmpl","_var","getYColTemplate","yCol","yVar","xVar","yDt","_typeof","Symbol","iterator","groupCol","multiData","_ret","groups","_ret2","yValues","_objectDestructuringEmpty","TypeError","WRAPPER_TEMPLATE","ITEM_TEMPLATE","cssNamespace","_ref2$opts","_data","getKey","compare","_sort","sort","toString","mediaQuery","alreadyImportedModules","createClass","ctor","superClass","Iterable","isIterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","offset","Math","max","newArr","ii","ensureSize","iter","size","__iterate","returnTrue","wrapIndex","uint32Index","NaN","wholeSlice","begin","end","resolveBegin","resolveIndex","resolveEnd","defaultIndex","min","Iterator","iteratorValue","iteratorResult","done","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","isArrayLike","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","object","_object","_keys","IterableSeq","_iterable","IteratorSeq","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","maybeIndexedSeqFromValue","seqIterate","reverse","useKeys","cache","maxIndex","entry","__iterateUncached","seqIterator","__iteratorUncached","json","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","is","valueA","valueB","valueOf","equals","deepEqual","__hash","notAssociative","entries","every","flipped","cacheResult","allEqual","bSize","has","NOT_SET","Repeat","times","_value","Infinity","EMPTY_REPEAT","invariant","condition","Range","step","abs","_start","_end","_step","ceil","EMPTY_RANGE","Collection","KeyedCollection","IndexedCollection","SetCollection","smi","i32","hash","h","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","uniqueID","assertNotInfinite","Map","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","count","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","prev","__prev","makeMap","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","shift","isLeafNode","mergeIntoNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","existing","deepMergerWith","mergeDeepWith","nextValue","collection","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","nextExisting","nextUpdated","popCount","setIn","idx","canEdit","newArray","spliceIn","newLen","after","spliceOut","pop","List","emptyList","isList","makeList","VNode","toArray","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","from","left","to","right","DONE","values","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","clear","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","OrderedMap","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","_list","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","includes","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","isKeyedIterable","singleton","concatSeq","flatten","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","stack","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","some","validateEntry","resolveSize","forceIterator","keyPath","Record","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_name","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","names","setProp","Set","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","StackPrototype","_head","EMPTY_STACK","methods","keyCopier","getOwnPropertySymbols","keyMapper","entryMapper","not","neg","quoteString","JSON","stringify","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","imul","SLICE$0","Keyed","Indexed","DELETE","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","of","__toString","searchValue","lastIndexOf","other","possibleIndex","floor","offsetValue","WeakMap","keyValues","updateIn","deleteIn","updatedValue","merge","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","removed","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","oldSize","unshift","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","union","intersect","originalSet","subtract","peek","pushAll","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","returnValue","find","findEntry","sideEffect","joined","isFirst","reducer","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","first","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","keyOf","last","lastKeyOf","maxBy","minBy","rest","skip","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","chain","mapEntries","mapKeys","KeyedIterablePrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","Immutable","addStylesToDom","styles","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","createLinkElement","linkElement","rel","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","replaceText","cssNode","childNodes","unescape","encodeURIComponent","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","mayRemove","textStore","replacement","Boolean","locals"],"mappings":"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","file":"d3-playbooks.riot-components.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(8);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {/* Riot v3.0.5, @license MIT */\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.riot = global.riot || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar __TAGS_CACHE = [];\n\tvar __TAG_IMPL = {};\n\tvar GLOBAL_MIXIN = '__global_mixin';\n\tvar RIOT_PREFIX = 'riot-';\n\tvar RIOT_TAG_IS = 'data-is';\n\tvar T_STRING = 'string';\n\tvar T_OBJECT = 'object';\n\tvar T_UNDEF  = 'undefined';\n\tvar T_FUNCTION = 'function';\n\tvar XLINK_NS = 'http://www.w3.org/1999/xlink';\n\tvar XLINK_REGEX = /^xlink:(\\w+)/;\n\tvar WIN = typeof window === T_UNDEF ? undefined : window;\n\tvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n\tvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n\tvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n\tvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\n\tvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n\tvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\n\tvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n\tvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\t\n\t/**\n\t * Check whether a DOM node must be considered a part of an svg document\n\t * @param   { String } name -\n\t * @returns { Boolean } -\n\t */\n\tfunction isSVGTag(name) {\n\t  return RE_SVG_TAGS.test(name)\n\t}\n\t\n\t/**\n\t * Check Check if the passed argument is undefined\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBoolAttr(value) {\n\t  return RE_BOOL_ATTRS.test(value)\n\t}\n\t\n\t/**\n\t * Check if passed argument is a function\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(value) {\n\t  return typeof value === T_FUNCTION || false // avoid IE problems\n\t}\n\t\n\t/**\n\t * Check if passed argument is an object, exclude null\n\t * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(value) {\n\t  return value && typeof value === T_OBJECT // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Check if passed argument is undefined\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isUndefined(value) {\n\t  return typeof value === T_UNDEF\n\t}\n\t\n\t/**\n\t * Check if passed argument is a string\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isString(value) {\n\t  return typeof value === T_STRING\n\t}\n\t\n\t/**\n\t * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n\t * @param { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBlank(value) {\n\t  return isUndefined(value) || value === null || value === ''\n\t}\n\t\n\t/**\n\t * Check if passed argument is a kind of array\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isArray(value) {\n\t  return Array.isArray(value) || value instanceof Array\n\t}\n\t\n\t/**\n\t * Check whether object's property could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } -\n\t */\n\tfunction isWritable(obj, key) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t  return isUndefined(obj[key]) || descriptor && descriptor.writable\n\t}\n\t\n\t/**\n\t * Check if passed argument is a reserved name\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isReservedName(value) {\n\t  return RE_RESERVED_NAMES.test(value)\n\t}\n\t\n\tvar check = Object.freeze({\n\t\tisSVGTag: isSVGTag,\n\t\tisBoolAttr: isBoolAttr,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisUndefined: isUndefined,\n\t\tisString: isString,\n\t\tisBlank: isBlank,\n\t\tisArray: isArray,\n\t\tisWritable: isWritable,\n\t\tisReservedName: isReservedName\n\t});\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Create a document fragment\n\t * @returns { Object } document fragment\n\t */\n\tfunction createFrag() {\n\t  return document.createDocumentFragment()\n\t}\n\t\n\t/**\n\t * Create a document text node\n\t * @returns { Object } create a text node to use as placeholder\n\t */\n\tfunction createDOMPlaceholder() {\n\t  return document.createTextNode('')\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - should we use a SVG as parent node?\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name, isSvg) {\n\t  return isSvg ?\n\t    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n\t    document.createElement(name)\n\t}\n\t\n\t/**\n\t * Get the outer html of any DOM node SVGs included\n\t * @param   { Object } el - DOM node to parse\n\t * @returns { String } el.outerHTML\n\t */\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML)\n\t    { return el.outerHTML }\n\t  // some browsers do not support outerHTML on the SVGs tags\n\t  else {\n\t    var container = mkEl('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we'll inject new html\n\t * @param { String } html - html to inject\n\t */\n\tfunction setInnerHTML(container, html) {\n\t  if (!isUndefined(container.innerHTML))\n\t    { container.innerHTML = html; }\n\t    // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml');\n\t    var node = container.ownerDocument.importNode(doc.documentElement, true);\n\t    container.appendChild(node);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name);\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  var xlink = XLINK_REGEX.exec(name);\n\t  if (xlink && xlink[1])\n\t    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n\t  else\n\t    { dom.setAttribute(name, val); }\n\t}\n\t\n\t/**\n\t * Insert safely a tag to fix #1962 #1649\n\t * @param   { HTMLElement } root - children container\n\t * @param   { HTMLElement } curr - node to insert\n\t * @param   { HTMLElement } next - node that should preceed the current node inserted\n\t */\n\tfunction safeInsert(root, curr, next) {\n\t  root.insertBefore(curr, next.parentNode && next);\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttrs(html, fn) {\n\t  if (!html)\n\t    { return }\n\t  var m;\n\t  while (m = RE_HTML_ATTRS.exec(html))\n\t    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t * @param   { Object }   context - fn can optionally return an object, which is passed to children\n\t */\n\tfunction walkNodes(dom, fn, context) {\n\t  if (dom) {\n\t    var res = fn(dom, context);\n\t    var next;\n\t    // stop the recursion\n\t    if (res === false) { return }\n\t\n\t    dom = dom.firstChild;\n\t\n\t    while (dom) {\n\t      next = dom.nextSibling;\n\t      walkNodes(dom, fn, res);\n\t      dom = next;\n\t    }\n\t  }\n\t}\n\t\n\tvar dom = Object.freeze({\n\t\t$$: $$,\n\t\t$: $,\n\t\tcreateFrag: createFrag,\n\t\tcreateDOMPlaceholder: createDOMPlaceholder,\n\t\tmkEl: mkEl,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tsetInnerHTML: setInnerHTML,\n\t\tremAttr: remAttr,\n\t\tgetAttr: getAttr,\n\t\tsetAttr: setAttr,\n\t\tsafeInsert: safeInsert,\n\t\twalkAttrs: walkAttrs,\n\t\twalkNodes: walkNodes\n\t});\n\t\n\tvar styleNode;\n\tvar cssTextProp;\n\tvar byName = {};\n\tvar remainder = [];\n\tvar needsInject = false;\n\t\n\t// skip the following code on the server\n\tif (WIN) {\n\t  styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style');\n\t    setAttr(newNode, 'type', 'text/css');\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]');\n\t    if (userNode) {\n\t      if (userNode.id) { newNode.id = userNode.id; }\n\t      userNode.parentNode.replaceChild(newNode, userNode);\n\t    }\n\t    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\t\n\t    return newNode\n\t  })();\n\t  cssTextProp = styleNode.styleSheet;\n\t}\n\t\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = {\n\t  styleNode: styleNode,\n\t  /**\n\t   * Save a tag style to be later injected into DOM\n\t   * @param { String } css - css string\n\t   * @param { String } name - if it's passed we will map the css to a tagname\n\t   */\n\t  add: function add(css, name) {\n\t    if (name) { byName[name] = css; }\n\t    else { remainder.push(css); }\n\t    needsInject = true;\n\t  },\n\t  /**\n\t   * Inject all previously saved tag styles into DOM\n\t   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t   */\n\t  inject: function inject() {\n\t    if (!WIN || !needsInject) { return }\n\t    needsInject = false;\n\t    var style = Object.keys(byName)\n\t      .map(function(k) { return byName[k] })\n\t      .concat(remainder).join('\\n');\n\t    if (cssTextProp) { cssTextProp.cssText = style; }\n\t    else { styleNode.innerHTML = style; }\n\t  }\n\t};\n\t\n\t/**\n\t * The riot template engine\n\t * @version v3.0.1\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\t/* global riot */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\t\n\t    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }';\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ];\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings;\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) { bp = _cache; }\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) { return _pairs }\n\t\n\t    var arr = pair.split(' ');\n\t\n\t    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n\t    arr[6] = _rewrite(_pairs[6], arr);\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n\t    arr[8] = pair;\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) { _bp = _cache; }\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6];\n\t\n\t    isexpr = start = re.lastIndex = 0;\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index;\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos));\n\t        start = re.lastIndex;\n\t        re = _bp[6 + (isexpr ^= 1)];\n\t        re.lastIndex = start;\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start));\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'));\n\t      } else {\n\t        parts.push(s);\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch];\n\t\n\t      recch.lastIndex = ix;\n\t      ix = 1;\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) { break }\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  };\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  };\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9]);\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  };\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  };\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair);\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite;\n\t      _cache[9] = _regex(_pairs[9]);\n\t    }\n\t    cachedBrackets = pair;\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b;\n\t\n\t    o = o || {};\n\t    b = o.brackets;\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    });\n\t    _settings = o;\n\t    _reset(b);\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  });\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n\t  _brackets.set = _reset;\n\t\n\t  _brackets.R_STRINGS = R_STRINGS;\n\t  _brackets.R_MLCOMMS = R_MLCOMMS;\n\t  _brackets.S_QBLOCKS = S_QBLOCKS;\n\t\n\t  return _brackets\n\t\n\t})();\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {};\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) { return str }\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr;\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys;\n\t\n\t  // istanbul ignore next\n\t  _tmpl.clearCache = function () { _cache = {}; };\n\t\n\t  _tmpl.errorHandler = null;\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    err.riotData = {\n\t      tagName: ctx && ctx.root && ctx.root.tagName,\n\t      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t    };\n\t\n\t    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\t    else if (\n\t      typeof console !== 'undefined' &&\n\t      typeof console.error === 'function'\n\t    ) {\n\t      if (err.riotData.tagName) {\n\t        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName.toLowerCase());\n\t      }\n\t      console.error(err);\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str);\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\t\n\t    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = String.fromCharCode(0x2057),\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g;\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = [];\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i];\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) { list[j++] = expr; }\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")';\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr);\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      });\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    };\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match;\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g;\n\t\n\t        expr = RegExp.rightContext;\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\t\n\t        jsb  = expr.slice(0, match.index);\n\t        expr = RegExp.rightContext;\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key);\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch];\n\t\n\t      ir.lastIndex = re.lastIndex;\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) { ++lv; }\n\t        else if (!--lv) { break }\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex;\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb;\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length;\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\t          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos));\n\t        }\n\t      }\n\t      return match\n\t    });\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"';\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)';\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  _tmpl.version = brackets.version = 'v3.0.1';\n\t\n\t  return _tmpl\n\t\n\t})();\n\t\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } list - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(list, fn) {\n\t  var len = list ? list.length : 0;\n\t\n\t  for (var i = 0, el; i < len; ++i) {\n\t    el = list[i];\n\t    // return false -> current item was removed by fn during the loop\n\t    if (fn(el, i) === false)\n\t      { i--; }\n\t  }\n\t  return list\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } array - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } -\n\t */\n\tfunction contains(array, item) {\n\t  return ~array.indexOf(item)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } str - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(str) {\n\t  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } str - source string\n\t * @param   { String } value - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(str, value) {\n\t  return str.slice(0, value.length) === value\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t * @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options));\n\t  return el\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments;\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          { src[key] = obj[key]; }\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\tvar misc = Object.freeze({\n\t\teach: each,\n\t\tcontains: contains,\n\t\ttoCamel: toCamel,\n\t\tstartsWith: startsWith,\n\t\tdefineProperty: defineProperty,\n\t\textend: extend\n\t});\n\t\n\tvar observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {};\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice;\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          { (callbacks[event] = callbacks[event] || []).push(fn); }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) { callbacks = {}; }\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event];\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) { arr.splice(i--, 1); }\n\t            }\n\t          } else { delete callbacks[event]; }\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on);\n\t          fn.apply(el, arguments);\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t        var arguments$1 = arguments;\n\t\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i;\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments$1[i + 1]; // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0);\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args);\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          { el.trigger.apply(el, ['*', event].concat(args)); }\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  });\n\t\n\t  return el\n\t\n\t};\n\t\n\tvar EVENTS_PREFIX_REGEX = /^on/;\n\t\n\t/**\n\t * Trigger DOM events\n\t * @param   { HTMLElement } dom - dom element target of the event\n\t * @param   { Function } handler - user function\n\t * @param   { Object } e - event object\n\t */\n\tfunction handleEvent(dom, handler, e) {\n\t  var ptag = this._parent,\n\t    item = this._item;\n\t\n\t  if (!item)\n\t    { while (ptag && !item) {\n\t      item = ptag._item;\n\t      ptag = ptag._parent;\n\t    } }\n\t\n\t  // override the event properties\n\t  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n\t  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n\t  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\t\n\t  e.item = item;\n\t\n\t  handler.call(this, e);\n\t\n\t  if (!e.preventUpdate) {\n\t    var p = getImmediateCustomParentTag(this);\n\t    // fixes #2083\n\t    if (p.isMounted) { p.update(); }\n\t  }\n\t}\n\t\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t  var eventName,\n\t    cb = handleEvent.bind(tag, dom, handler);\n\t\n\t  if (!dom.addEventListener) {\n\t    dom[name] = cb;\n\t    return\n\t  }\n\t\n\t  // avoid to bind twice the same event\n\t  dom[name] = null;\n\t\n\t  // normalize event name\n\t  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\t\n\t  // cache the callback directly on the DOM node\n\t  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\t\n\t  if (dom._riotEvents[name])\n\t    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\t\n\t  dom._riotEvents[name] = cb;\n\t  dom.addEventListener(eventName, cb, false);\n\t}\n\t\n\t/**\n\t * Update dynamically created data-is tags with changing expressions\n\t * @param { Object } expr - expression tag and expression info\n\t * @param { Tag } parent - parent for tag creation\n\t */\n\tfunction updateDataIs(expr, parent) {\n\t  var tagName = tmpl(expr.value, parent),\n\t    conf;\n\t\n\t  if (expr.tag && expr.tagName === tagName) {\n\t    expr.tag.update();\n\t    return\n\t  }\n\t\n\t  // sync _parent to accommodate changing tagnames\n\t  if (expr.tag) {\n\t    var delName = expr.value,\n\t      tags = expr.tag._parent.tags;\n\t\n\t    setAttr(expr.tag.root, RIOT_TAG_IS, tagName); // update for css\n\t    arrayishRemove(tags, delName, expr.tag);\n\t  }\n\t\n\t  expr.impl = __TAG_IMPL[tagName];\n\t  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n\t  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n\t  expr.tagName = tagName;\n\t  expr.tag.mount();\n\t  expr.tag.update();\n\t\n\t  // parent is the placeholder tag, not the dynamic tag so clean up\n\t  parent.on('unmount', function () {\n\t    var delName = expr.tag.opts.dataIs,\n\t      tags = expr.tag.parent.tags,\n\t      _tags = expr.tag._parent.tags;\n\t    arrayishRemove(tags, delName, expr.tag);\n\t    arrayishRemove(_tags, delName, expr.tag);\n\t    expr.tag.unmount();\n\t  });\n\t}\n\t\n\t/**\n\t * Update on single tag expression\n\t * @this Tag\n\t * @param { Object } expr - expression logic\n\t * @returns { undefined }\n\t */\n\tfunction updateExpression(expr) {\n\t  var dom = expr.dom,\n\t    attrName = expr.attr,\n\t    isToggle = /^(show|hide)$/.test(attrName),\n\t    // the value for the toggle must consider also the parent tag\n\t    value = isToggle ? tmpl(expr.expr, extend({}, this, this.parent)) : tmpl(expr.expr, this),\n\t    isValueAttr = attrName === 'riot-value',\n\t    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n\t    parent = dom && (expr.parent || dom.parentNode),\n\t    old;\n\t\n\t  if (expr.bool)\n\t    { value = value ? attrName : false; }\n\t  else if (isUndefined(value) || value === null)\n\t    { value = ''; }\n\t\n\t  if (expr._riot_id) { // if it's a tag\n\t    if (expr.isMounted) {\n\t      expr.update();\n\t\n\t    // if it hasn't been mounted yet, do that now.\n\t    } else {\n\t      expr.mount();\n\t\n\t      if (isVirtual) {\n\t        var frag = document.createDocumentFragment();\n\t        makeVirtual.call(expr, frag);\n\t        expr.root.parentElement.replaceChild(frag, expr.root);\n\t      }\n\t    }\n\t    return\n\t  }\n\t\n\t  old = expr.value;\n\t  expr.value = value;\n\t\n\t  if (expr.update) {\n\t    expr.update();\n\t    return\n\t  }\n\t\n\t  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n\t  if (old === value) { return }\n\t  // no change, so nothing more to do\n\t  if (isValueAttr && dom.value === value) { return }\n\t\n\t  // textarea and text nodes have no attribute name\n\t  if (!attrName) {\n\t    // about #815 w/o replace: the browser converts the value to a string,\n\t    // the comparison by \"==\" does too, but not in the server\n\t    value += '';\n\t    // test for parent avoids error with invalid assignment to nodeValue\n\t    if (parent) {\n\t      // cache the parent node because somehow it will become null on IE\n\t      // on the next iteration\n\t      expr.parent = parent;\n\t      if (parent.tagName === 'TEXTAREA') {\n\t        parent.value = value;                    // #1113\n\t        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n\t      }                                         // will be available on 'updated'\n\t      else { dom.nodeValue = value; }\n\t    }\n\t    return\n\t  }\n\t\n\t  // remove original attribute\n\t  if (!expr.isAttrRemoved || !value) {\n\t    remAttr(dom, attrName);\n\t    expr.isAttrRemoved = true;\n\t  }\n\t\n\t  // event handler\n\t  if (isFunction(value)) {\n\t    setEventHandler(attrName, value, dom, this);\n\t  // show / hide\n\t  } else if (isToggle) {\n\t    if (attrName === 'hide') { value = !value; }\n\t    dom.style.display = value ? '' : 'none';\n\t  // field value\n\t  } else if (isValueAttr) {\n\t    dom.value = value;\n\t  // <img src=\"{ expr }\">\n\t  } else if (startsWith(attrName, RIOT_PREFIX) && attrName !== RIOT_TAG_IS) {\n\t    attrName = attrName.slice(RIOT_PREFIX.length);\n\t    if (CASE_SENSITIVE_ATTRIBUTES[attrName])\n\t      { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n\t    if (value != null)\n\t      { setAttr(dom, attrName, value); }\n\t  } else {\n\t    // <select> <option selected={true}> </select>\n\t    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value) {\n\t      parent.value = dom.value;\n\t    } if (expr.bool) {\n\t      dom[attrName] = value;\n\t      if (!value) { return }\n\t    } if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      setAttr(dom, attrName, value);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Update all the expressions in a Tag instance\n\t * @this Tag\n\t * @param { Array } expressions - expression that must be re evaluated\n\t */\n\tfunction updateAllExpressions(expressions) {\n\t  each(expressions, updateExpression.bind(this));\n\t}\n\t\n\tvar IfExpr = {\n\t  init: function init(dom, parentTag, expr) {\n\t    remAttr(dom, 'if');\n\t    this.parentTag = parentTag;\n\t    this.expr = expr;\n\t    this.stub = document.createTextNode('');\n\t    this.pristine = dom;\n\t\n\t    var p = dom.parentNode;\n\t    p.insertBefore(this.stub, dom);\n\t    p.removeChild(dom);\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var newValue = tmpl(this.expr, this.parentTag);\n\t\n\t    if (newValue && !this.current) { // insert\n\t      this.current = this.pristine.cloneNode(true);\n\t      this.stub.parentNode.insertBefore(this.current, this.stub);\n\t\n\t      this.expressions = [];\n\t      parseExpressions.apply(this.parentTag, [this.current, this.expressions, true]);\n\t    } else if (!newValue && this.current) { // remove\n\t      unmountAll(this.expressions);\n\t      if (this.current._tag) {\n\t        this.current._tag.unmount();\n\t      } else if (this.current.parentNode)\n\t        { this.current.parentNode.removeChild(this.current); }\n\t      this.current = null;\n\t      this.expressions = [];\n\t    }\n\t\n\t    if (newValue) { updateAllExpressions.call(this.parentTag, this.expressions); }\n\t  },\n\t  unmount: function unmount() {\n\t    unmountAll(this.expressions || []);\n\t    delete this.pristine;\n\t    delete this.parentNode;\n\t    delete this.stub;\n\t  }\n\t};\n\t\n\tvar RefExpr = {\n\t  init: function init(dom, attrName, attrValue, parent) {\n\t    this.dom = dom;\n\t    this.attr = attrName;\n\t    this.rawValue = attrValue;\n\t    this.parent = parent;\n\t    this.hasExp = tmpl.hasExpr(attrValue);\n\t    this.firstRun = true;\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var value = this.rawValue;\n\t    if (this.hasExp)\n\t      { value = tmpl(this.rawValue, this.parent); }\n\t\n\t    // if nothing changed, we're done\n\t    if (!this.firstRun && value === this.value) { return }\n\t\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t\n\t    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\t    var tagOrDom = this.tag || this.dom;\n\t\n\t    // the name changed, so we need to remove it from the old key (if present)\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t\n\t    if (isBlank(value)) {\n\t      // if the value is blank, we remove it\n\t      remAttr(this.dom, this.attr);\n\t    } else {\n\t      // add it to the refs of parent tag (this behavior was changed >=3.0)\n\t      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n\t      // set the actual DOM attr\n\t      setAttr(this.dom, this.attr, value);\n\t    }\n\t    this.value = value;\n\t    this.firstRun = false;\n\t  },\n\t  unmount: function unmount() {\n\t    var tagOrDom = this.tag || this.dom;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t    delete this.dom;\n\t    delete this.parent;\n\t  }\n\t};\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @param   { Object } base - prototype object for the new item\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val, base) {\n\t  var item = base ? Object.create(base) : {};\n\t  item[expr.key] = key;\n\t  if (expr.pos) { item[expr.pos] = val; }\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t * @param   { String } tagName - key used to identify the type of tag\n\t * @param   { Object } parent - parent tag to remove the child from\n\t */\n\tfunction unmountRedundant(items, tags, tagName, parent) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t;\n\t\n\t  while (i > j) {\n\t    t = tags[--i];\n\t    tags.splice(i, 1);\n\t    t.unmount();\n\t    arrayishRemove(parent.tags, tagName, t, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @this Tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(i) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(this.tags), function (tagName) {\n\t    var tag = this$1.tags[tagName];\n\t    if (isArray(tag))\n\t      { each(tag, function (t) {\n\t        moveChildTag.apply(t, [tagName, i]);\n\t      }); }\n\t    else\n\t      { moveChildTag.apply(tag, [tagName, i]); }\n\t  });\n\t}\n\t\n\t/**\n\t * Move a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction move(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { moveVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Insert and mount a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction insert(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Append a new tag into the DOM\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction append(root, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.call(this, root); }\n\t  else\n\t    { root.appendChild(this.root); }\n\t}\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { HTMLElement } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t * @returns { Object } expression object for this each loop\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each');\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n\t    useRoot = RE_SPECIAL_TAGS.test(tagName),\n\t    parentNode = dom.parentNode,\n\t    ref = createDOMPlaceholder(),\n\t    child = getTag(dom),\n\t    ifExpr = getAttr(dom, 'if'),\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isLoop = true,\n\t    isAnonymous = !__TAG_IMPL[tagName],\n\t    isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr);\n\t  expr.isLoop = true;\n\t\n\t  if (ifExpr) { remAttr(dom, 'if'); }\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  parentNode.insertBefore(ref, dom);\n\t  parentNode.removeChild(dom);\n\t\n\t  expr.update = function updateEach() {\n\t\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      frag = createFrag(),\n\t      root = ref.parentNode;\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false;\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, items[key], key)\n\t        }) : [];\n\t    } else {\n\t      hasKeys = false;\n\t    }\n\t\n\t    if (ifExpr) {\n\t      items = items.filter(function(item, i) {\n\t        if (expr.key) {\n\t          return !!tmpl(ifExpr, mkitem(expr, item, i, parent))\n\t        }\n\t        // in case it's not a keyed loop\n\t        // we test the validity of the if expression against\n\t        // the item and the parent\n\t        return !!tmpl(ifExpr, parent) || !!tmpl(ifExpr, item)\n\t      });\n\t    }\n\t\n\t    // loop all the new items\n\t    each(items, function(item, i) {\n\t      // reorder only if the items are objects\n\t      var\n\t        _mustReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos];\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        var mustAppend = i === tags.length;\n\t\n\t        tag = new Tag$$1(impl, {\n\t          parent: parent,\n\t          isLoop: isLoop,\n\t          isAnonymous: isAnonymous,\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML);\n\t\n\t        // mount the tag\n\t        tag.mount();\n\t\n\t        if (mustAppend)\n\t          { append.apply(tag, [frag || root, isVirtual]); }\n\t        else\n\t          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\t\n\t        if (!mustAppend) { oldItems.splice(i, 0, item); }\n\t        tags.splice(i, 0, tag);\n\t        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n\t        pos = i; // handled here so no move\n\t      } else { tag.update(item); }\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (pos !== i && _mustReorder) {\n\t        // #closes 2040\n\t        if (contains(items, oldItems[i])) {\n\t          move.apply(tag, [root, tags[i], isVirtual]);\n\t        }\n\t        // update the position attribute if it exists\n\t        if (expr.pos) { tag[expr.pos] = i; }\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item;\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent);\n\t    });\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags, tagName, parent);\n\t\n\t    // clone the items array\n\t    oldItems = items.slice();\n\t\n\t    root.insertBefore(frag, ref);\n\t  };\n\t\n\t  expr.unmount = function() {\n\t    each(tags, function(t) { t.unmount(); });\n\t  };\n\t\n\t  return expr\n\t}\n\t\n\t/**\n\t * Walk the tag DOM to detect the expressions to evaluate\n\t * @this Tag\n\t * @param   { HTMLElement } root - root tag where we will start digging the expressions\n\t * @param   { Array } expressions - empty array where the expressions will be added\n\t * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n\t * @returns { Object } an object containing the root noode and the dom tree\n\t */\n\tfunction parseExpressions(root, expressions, mustIncludeRoot) {\n\t  var this$1 = this;\n\t\n\t  var tree = {parent: {children: expressions}};\n\t\n\t  walkNodes(root, function (dom, ctx) {\n\t    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n\t    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\t\n\t    // text node\n\t    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n\t      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\t\n\t    if (type !== 1) { return ctx } // not an element\n\t\n\t    // loop. each does it's own thing (for now)\n\t    if (attr = getAttr(dom, 'each')) {\n\t      parent.children.push(_each(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    // if-attrs become the new parent. Any following expressions (either on the current\n\t    // element, or below it) become children of this expression.\n\t    if (attr = getAttr(dom, 'if')) {\n\t      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    if (expr = getAttr(dom, RIOT_TAG_IS)) {\n\t      if (tmpl.hasExpr(expr)) {\n\t        parent.children.push({isRtag: true, expr: expr, dom: dom});\n\t        return false\n\t      }\n\t    }\n\t\n\t    // if this is a tag, stop traversing here.\n\t    // we ignore the root, since parseExpressions is called while we're mounting that root\n\t    tagImpl = getTag(dom);\n\t    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n\t      var conf = {root: dom, parent: this$1, hasImpl: true};\n\t      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n\t      return false\n\t    }\n\t\n\t    // attribute expressions\n\t    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n\t      if (!expr) { return }\n\t      parent.children.push(expr);\n\t    }]);\n\t\n\t    // whatever the parent is, all child elements get the same parent.\n\t    // If this element had an if-attr, that's the parent for all child elements\n\t    return {parent: parent}\n\t  }, tree);\n\t\n\t  return { tree: tree, root: root }\n\t}\n\t\n\t/**\n\t * Calls `fn` for every attribute on an element. If that attr has an expression,\n\t * it is also passed to fn.\n\t * @this Tag\n\t * @param   { HTMLElement } dom - dom node to parse\n\t * @param   { Array } attrs - array of attributes\n\t * @param   { Function } fn - callback to exec on any iteration\n\t */\n\tfunction parseAttributes(dom, attrs, fn) {\n\t  var this$1 = this;\n\t\n\t  each(attrs, function (attr) {\n\t    var name = attr.name, bool = isBoolAttr(name), expr;\n\t\n\t    if (~['ref', 'data-ref'].indexOf(name)) {\n\t      expr =  Object.create(RefExpr).init(dom, name, attr.value, this$1);\n\t    } else if (tmpl.hasExpr(attr.value)) {\n\t      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n\t    }\n\t\n\t    fn(attr, expr);\n\t  });\n\t}\n\t\n\t/*\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\t\n\tvar reHasYield  = /<yield\\b/i;\n\tvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n\tvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n\tvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n\tvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n\tvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n\tvar GENERIC = 'div';\n\t\n\t\n\t/*\n\t  Creates the root element for table or select child elements:\n\t  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t*/\n\tfunction specialTags(el, tmpl, tagName) {\n\t\n\t  var\n\t    select = tagName[0] === 'o',\n\t    parent = select ? 'select>' : 'table>';\n\t\n\t  // trim() is important here, this ensures we don't have artifacts,\n\t  // so we can check if we have only one element inside the parent\n\t  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n\t  parent = el.firstChild;\n\t\n\t  // returns the immediate parent if tr/th/td/col is the only element, if not\n\t  // returns the whole tree, as this can include additional elements\n\t  if (select) {\n\t    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n\t  } else {\n\t    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t    var tname = rootEls[tagName];\n\t    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n\t  }\n\t  return parent\n\t}\n\t\n\t/*\n\t  Replace the yield tag from any tag template with the innerHTML of the\n\t  original tag in the page\n\t*/\n\tfunction replaceYield(tmpl, html) {\n\t  // do nothing if no yield\n\t  if (!reHasYield.test(tmpl)) { return tmpl }\n\t\n\t  // be careful with #1343 - string on the source having `$1`\n\t  var src = {};\n\t\n\t  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t    src[ref] = src[ref] || text;   // preserve first definition\n\t    return ''\n\t  }).trim();\n\t\n\t  return tmpl\n\t    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t      return src[ref] || def || ''\n\t    })\n\t    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t      return html || def || ''\n\t    })\n\t}\n\t\n\t/**\n\t * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t *\n\t * @param   { String } tmpl  - The template coming from the custom tag definition\n\t * @param   { String } html - HTML content that comes from the DOM element where you\n\t *           will mount the tag, mostly the original tag in the page\n\t * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n\t * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n\t */\n\tfunction mkdom(tmpl, html, checkSvg) {\n\t  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n\t    tagName = match && match[1].toLowerCase(),\n\t    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\t\n\t  // replace all the yield tags with the tag inner html\n\t  tmpl = replaceYield(tmpl, html);\n\t\n\t  /* istanbul ignore next */\n\t  if (tblTags.test(tagName))\n\t    { el = specialTags(el, tmpl, tagName); }\n\t  else\n\t    { setInnerHTML(el, tmpl); }\n\t\n\t  el.stub = true;\n\t\n\t  return el\n\t}\n\t\n\t/**\n\t * Another way to create a riot tag a bit more es6 friendly\n\t * @param { HTMLElement } el - tag DOM selector or DOM node/s\n\t * @param { Object } opts - tag logic\n\t * @returns { Tag } new riot tag instance\n\t */\n\tfunction Tag$1(el, opts) {\n\t  // get the tag properties from the class constructor\n\t  var ref = this;\n\t  var name = ref.name;\n\t  var tmpl = ref.tmpl;\n\t  var css = ref.css;\n\t  var attrs = ref.attrs;\n\t  var onCreate = ref.onCreate;\n\t  // register a new tag and cache the class prototype\n\t  if (!__TAG_IMPL[name]) {\n\t    tag$$1(name, tmpl, css, attrs, onCreate);\n\t    // cache the class constructor\n\t    __TAG_IMPL[name].class = this.constructor;\n\t  }\n\t\n\t  // mount the tag using the class instance\n\t  mountTo(el, name, opts, this);\n\t  // inject the component css\n\t  if (css) { styleManager.inject(); }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag$$1(name, tmpl, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs;\n\t\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css;\n\t      css = '';\n\t    } else\n\t      { attrs = ''; }\n\t  }\n\t\n\t  if (css) {\n\t    if (isFunction(css))\n\t      { fn = css; }\n\t    else\n\t      { styleManager.add(css); }\n\t  }\n\t\n\t  name = name.toLowerCase();\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag2$$1(name, tmpl, css, attrs, fn) {\n\t  if (css)\n\t    { styleManager.add(css, name); }\n\t\n\t  var exists = !!__TAG_IMPL[name];\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  if (exists && util.hotReloader)\n\t    { util.hotReloader(name); }\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { * } selector - tag DOM selector or DOM node/s\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\tfunction mount$$1(selector, tagName, opts) {\n\t  var tags = [];\n\t\n\t  function pushTagsTo(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG_IS);\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName;\n\t        setAttr(root, RIOT_TAG_IS, tagName);\n\t      }\n\t\n\t      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\t\n\t      if (tag$$1)\n\t        { tags.push(tag$$1); }\n\t    } else if (root.length)\n\t      { each(root, pushTagsTo); } // assume nodeList\n\t  }\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject();\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName;\n\t    tagName = 0;\n\t  }\n\t\n\t  var elem;\n\t  var allTags;\n\t\n\t  // crawl the DOM to find the tag\n\t  if (isString(selector)) {\n\t    selector = selector === '*' ?\n\t      // select all registered tags\n\t      // & tags found with the riot-tag attribute set\n\t      allTags = selectTags() :\n\t      // or just the ones named like the selector\n\t      selector + selectTags(selector.split(/, */));\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    elem = selector ? $$(selector) : [];\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    { elem = selector; }\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectTags();\n\t    // if the root els it's just a single tag\n\t    if (elem.tagName)\n\t      { elem = $$(tagName, elem); }\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = [];\n\t\n\t      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\t\n\t      elem = nodeList;\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0;\n\t  }\n\t\n\t  pushTagsTo(elem);\n\t\n\t  return tags\n\t}\n\t\n\t// Create a mixin that could be globally shared across all the tags\n\tvar mixins = {};\n\tvar globals = mixins[GLOBAL_MIXIN] = {};\n\tvar _id = 0;\n\t\n\t/**\n\t * Create/Return a mixin by its name\n\t * @param   { String }  name - mixin name (global mixin if object)\n\t * @param   { Object }  mix - mixin logic\n\t * @param   { Boolean } g - is global?\n\t * @returns { Object }  the mixin logic\n\t */\n\tfunction mixin$$1(name, mix, g) {\n\t  // Unnamed global\n\t  if (isObject(name)) {\n\t    mixin$$1((\"__unnamed_\" + (_id++)), name, true);\n\t    return\n\t  }\n\t\n\t  var store = g ? globals : mixins;\n\t\n\t  // Getter\n\t  if (!mix) {\n\t    if (isUndefined(store[name]))\n\t      { throw new Error('Unregistered mixin: ' + name) }\n\t\n\t    return store[name]\n\t  }\n\t\n\t  // Setter\n\t  store[name] = isFunction(mix) ?\n\t    extend(mix.prototype, store[name] || {}) && mix :\n\t    extend(store[name] || {}, mix);\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\tfunction update$1() {\n\t  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n\t}\n\t\n\tfunction unregister$$1(name) {\n\t  delete __TAG_IMPL[name];\n\t}\n\t\n\t// counter to give a unique id to all the Tag instances\n\tvar __uid = 0;\n\t\n\t/**\n\t * We need to update opts for this tag. That requires updating the expressions\n\t * in any attributes on the tag, and then copying the result onto opts.\n\t * @this Tag\n\t * @param   {Boolean} isLoop - is it a loop tag?\n\t * @param   { Tag }  parent - parent tag node\n\t * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n\t * @param   { Object }  opts - tag options\n\t * @param   { Array }  instAttrs - tag attributes array\n\t */\n\tfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n\t  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n\t  // (and only this case) we don't need to do updateOpts, because the regular parse\n\t  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n\t  if (isLoop && isAnonymous) { return }\n\t\n\t  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\t  each(instAttrs, function (attr) {\n\t    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n\t    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Tag class\n\t * @constructor\n\t * @param { Object } impl - it contains the tag template, and logic\n\t * @param { Object } conf - tag options\n\t * @param { String } innerHTML - html that eventually we need to inject in the tag\n\t */\n\tfunction Tag$$1(impl, conf, innerHTML) {\n\t\n\t  var opts = extend({}, conf.opts),\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    isAnonymous = conf.isAnonymous,\n\t    item = cleanUpData(conf.item),\n\t    instAttrs = [], // All attributes on the Tag when it's first parsed\n\t    implAttrs = [], // expressions on this type of Tag\n\t    expressions = [],\n\t    root = conf.root,\n\t    tagName = conf.tagName || getTagName(root),\n\t    isVirtual = tagName === 'virtual',\n\t    propsInSyncWithParent = [],\n\t    dom;\n\t\n\t  // make this tag observable\n\t  observable(this);\n\t  // only call unmount if we have a valid __TAG_IMPL (has name property)\n\t  if (impl.name && root._tag) { root._tag.unmount(true); }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false;\n\t  root.isLoop = isLoop;\n\t\n\t  defineProperty(this, '_internal', {\n\t    isAnonymous: isAnonymous,\n\t    instAttrs: instAttrs,\n\t    innerHTML: innerHTML,\n\t    // these vars will be needed only for the virtual tags\n\t    virts: [],\n\t    tail: null,\n\t    head: null\n\t  });\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { root: root, opts: opts }, item);\n\t  defineProperty(this, 'parent', parent || false);\n\t  // protect the \"tags\" and \"refs\" property from being overridden\n\t  defineProperty(this, 'tags', {});\n\t  defineProperty(this, 'refs', {});\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'update', function tagUpdate(data) {\n\t    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data);\n\t\n\t    // inherit properties from the parent, but only for isAnonymous tags\n\t    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n\t    extend(this, data);\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t    if (this.isMounted) { this.trigger('update', data); }\n\t    updateAllExpressions.call(this, expressions);\n\t    if (this.isMounted) { this.trigger('updated'); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Add a mixin to this tag\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mixin', function tagMixin() {\n\t    var this$1 = this;\n\t\n\t    each(arguments, function (mix) {\n\t      var instance,\n\t        props = [],\n\t        obj;\n\t\n\t      mix = isString(mix) ? mixin$$1(mix) : mix;\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix();\n\t      } else { instance = mix; }\n\t\n\t      var proto = Object.getPrototypeOf(instance);\n\t\n\t      // build multilevel prototype inheritance chain property list\n\t      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n\t      while (obj = Object.getPrototypeOf(obj || instance))\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(props, function (key) {\n\t        // bind methods to this\n\t        // allow mixins to override other properties/parent mixins\n\t        if (key !== 'init') {\n\t          // check for getters/setters\n\t          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n\t          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\t\n\t          // apply method only if it does not already exist on the instance\n\t          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n\t            Object.defineProperty(this$1, key, descriptor);\n\t          } else {\n\t            this$1[key] = isFunction(instance[key]) ?\n\t              instance[key].bind(this$1) :\n\t              instance[key];\n\t          }\n\t        }\n\t      });\n\t\n\t      // init method will be called automatically\n\t      if (instance.init)\n\t        { instance.init.bind(this$1)(); }\n\t    });\n\t    return this\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Mount the current tag instance\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mount', function tagMount() {\n\t    var this$1 = this;\n\t\n\t    root._tag = this; // keep a reference to the tag just created\n\t\n\t    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\t    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n\t      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n\t      attr.expr = expr;\n\t      instAttrs.push(attr);\n\t    }]);\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    implAttrs = [];\n\t    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n\t    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n\t      if (expr) { expressions.push(expr); }\n\t      else { setAttr(root, attr.name, attr.value); }\n\t    }]);\n\t\n\t    // children in loop should inherit from true parent\n\t    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\t\n\t    // initialiation\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t\n\t    // add global mixins\n\t    var globalMixin = mixin$$1(GLOBAL_MIXIN);\n\t\n\t    if (globalMixin) {\n\t      for (var i in globalMixin) {\n\t        if (globalMixin.hasOwnProperty(i)) {\n\t          this$1.mixin(globalMixin[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (impl.fn) { impl.fn.call(this, opts); }\n\t\n\t    this.trigger('before-mount');\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions.apply(this, [dom, expressions, false]);\n\t\n\t    this.update(item);\n\t\n\t    if (isLoop && isAnonymous) {\n\t      // update the root attribute for the looped elements\n\t      this.root = root = dom.firstChild;\n\t    } else {\n\t      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n\t      if (root.stub) { root = parent.root; }\n\t    }\n\t\n\t    defineProperty(this, 'root', root);\n\t    this.isMounted = true;\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!this.parent || this.parent.isMounted) {\n\t      this.trigger('mount');\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else { this.parent.one('mount', function () {\n\t      this$1.trigger('mount');\n\t    }); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Unmount the tag instance\n\t   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n\t    var this$1 = this;\n\t\n\t    var el = this.root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __TAGS_CACHE.indexOf(this);\n\t\n\t    this.trigger('before-unmount');\n\t\n\t    // clear all attributes coming from the mounted tag\n\t    walkAttrs(impl.attrs, function (name) {\n\t      if (startsWith(name, RIOT_PREFIX))\n\t        { name = name.slice(RIOT_PREFIX.length); }\n\t      remAttr(root, name);\n\t    });\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      { __TAGS_CACHE.splice(tagIndex, 1); }\n\t\n\t    if (p) {\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent);\n\t\n\t        if (isVirtual) {\n\t          Object.keys(this.tags).forEach(function (tagName) {\n\t            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n\t          });\n\t        } else {\n\t          arrayishRemove(ptag.tags, tagName, this);\n\t        }\n\t      } else {\n\t        while (el.firstChild) { el.removeChild(el.firstChild); }\n\t      }\n\t\n\t      if (!mustKeepRoot) {\n\t        p.removeChild(el);\n\t      } else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, RIOT_TAG_IS);\n\t      }\n\t    }\n\t\n\t    if (this._internal.virts) {\n\t      each(this._internal.virts, function (v) {\n\t        if (v.parentNode) { v.parentNode.removeChild(v); }\n\t      });\n\t    }\n\t\n\t    // allow expressions to unmount themselves\n\t    unmountAll(expressions);\n\t    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\t\n\t    this.trigger('unmount');\n\t    this.off('*');\n\t    this.isMounted = false;\n\t\n\t    delete this.root._tag;\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __TAG_IMPL[getAttr(dom, RIOT_TAG_IS) ||\n\t    getAttr(dom, RIOT_TAG_IS) || dom.tagName.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Inherit properties from a target tag instance\n\t * @this Tag\n\t * @param   { Tag } target - tag where we will inherit properties\n\t * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n\t */\n\tfunction inheritFrom(target, propsInSyncWithParent) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(target), function (k) {\n\t    // some properties must be always in sync with the parent tag\n\t    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\t\n\t    if (isUndefined(this$1[k]) || mustSync) {\n\t      // track the property to keep in sync\n\t      // so we can keep it updated\n\t      if (!mustSync) { propsInSyncWithParent.push(k); }\n\t      this$1[k] = target[k];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @this Tag\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tagName, newPos) {\n\t  var parent = this.parent,\n\t    tags;\n\t  // no parent no move\n\t  if (!parent) { return }\n\t\n\t  tags = parent.tags[tagName];\n\t\n\t  if (isArray(tags))\n\t    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n\t  else { arrayishAdd(parent.tags, tagName, this); }\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag$$1(child, opts, innerHTML),\n\t    tagName = opts.tagName || getTagName(opts.root, true),\n\t    ptag = getImmediateCustomParentTag(parent);\n\t  // fix for the parent attribute in the looped elements\n\t  defineProperty(tag, 'parent', ptag);\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent;\n\t\n\t  // add this tag to the custom parent tag\n\t  arrayishAdd(ptag.tags, tagName, tag);\n\t\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    { arrayishAdd(parent.tags, tagName, tag); }\n\t\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = '';\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag;\n\t  while (ptag._internal.isAnonymous) {\n\t    if (!ptag.parent) { break }\n\t    ptag = ptag.parent;\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Trigger the unmount method on all the expressions\n\t * @param   { Array } expressions - DOM expressions\n\t */\n\tfunction unmountAll(expressions) {\n\t  each(expressions, function(expr) {\n\t    if (expr instanceof Tag$$1) { expr.unmount(true); }\n\t    else if (expr.unmount) { expr.unmount(); }\n\t  });\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom, skipDataIs) {\n\t  var child = getTag(dom),\n\t    namedTag = !skipDataIs && getAttr(dom, RIOT_TAG_IS);\n\t  return namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t}\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag$$1) && !(data && typeof data.trigger === T_FUNCTION))\n\t    { return data }\n\t\n\t  var o = {};\n\t  for (var key in data) {\n\t    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Set the property of an object for a given key. If something already\n\t * exists there, then it becomes an array containing both the old and new value.\n\t * @param { Object } obj - object on which to set the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be set\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t */\n\tfunction arrayishAdd(obj, key, value, ensureArray) {\n\t  var dest = obj[key];\n\t  var isArr = isArray(dest);\n\t\n\t  if (dest && dest === value) { return }\n\t\n\t  // if the key was never set, set it once\n\t  if (!dest && ensureArray) { obj[key] = [value]; }\n\t  else if (!dest) { obj[key] = value; }\n\t  // if it was an array and not yet set\n\t  else if (!isArr || isArr && !contains(dest, value)) {\n\t    if (isArr) { dest.push(value); }\n\t    else { obj[key] = [dest, value]; }\n\t  }\n\t}\n\t\n\t/**\n\t * Removes an item from an object at a given key. If the key points to an array,\n\t * then the item is just removed from the array.\n\t * @param { Object } obj - object on which to remove the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be removed\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t*/\n\tfunction arrayishRemove(obj, key, value, ensureArray) {\n\t  if (isArray(obj[key])) {\n\t    each(obj[key], function(item, i) {\n\t      if (item === value) { obj[key].splice(i, 1); }\n\t    });\n\t    if (!obj[key].length) { delete obj[key]; }\n\t    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n\t  } else\n\t    { delete obj[key]; } // otherwise just delete the key\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub)\n\t      { return true }\n\t    dom = dom.parentNode;\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts, ctx) {\n\t  var impl = __TAG_IMPL[tagName],\n\t    implClass = __TAG_IMPL[tagName].class,\n\t    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\t\n\t  // clear the inner html\n\t  root.innerHTML = '';\n\t\n\t  var conf = { root: root, opts: opts };\n\t  if (opts && opts.parent) { conf.parent = opts.parent; }\n\t\n\t  if (impl && root) { Tag$$1.apply(tag, [impl, conf, innerHTML]); }\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount(true);\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n\t  }\n\t\n\t  return tag\n\t}\n\t\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @this Tag\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction makeVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var head = createDOMPlaceholder(),\n\t    tail = createDOMPlaceholder(),\n\t    frag = createFrag(),\n\t    sib, el;\n\t\n\t  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n\t  this._internal.tail = this.root.appendChild(tail);\n\t\n\t  el = this._internal.head;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    this$1._internal.virts.push(el); // hold for unmounting\n\t    el = sib;\n\t  }\n\t\n\t  if (target)\n\t    { src.insertBefore(frag, target._internal.head); }\n\t  else\n\t    { src.appendChild(frag); }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @this Tag\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t */\n\tfunction moveVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var el = this._internal.head,\n\t    frag = createFrag(),\n\t    sib;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    el = sib;\n\t    if (el === this$1._internal.tail) {\n\t      frag.appendChild(el);\n\t      src.insertBefore(frag, target._internal.head);\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Get selectors for tags\n\t * @param   { Array } tags - tag names to select\n\t * @returns { String } selector\n\t */\n\tfunction selectTags(tags) {\n\t  // select all tags\n\t  if (!tags) {\n\t    var keys = Object.keys(__TAG_IMPL);\n\t    return keys + selectTags(keys)\n\t  }\n\t\n\t  return tags\n\t    .filter(function (t) { return !/[^-\\w]/.test(t); })\n\t    .reduce(function (list, t) {\n\t      var name = t.trim().toLowerCase();\n\t      return list + \",[\" + RIOT_TAG_IS + \"=\\\"\" + name + \"\\\"]\"\n\t    }, '')\n\t}\n\t\n\t\n\tvar tags = Object.freeze({\n\t\tgetTag: getTag,\n\t\tinheritFrom: inheritFrom,\n\t\tmoveChildTag: moveChildTag,\n\t\tinitChildTag: initChildTag,\n\t\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\t\tunmountAll: unmountAll,\n\t\tgetTagName: getTagName,\n\t\tcleanUpData: cleanUpData,\n\t\tarrayishAdd: arrayishAdd,\n\t\tarrayishRemove: arrayishRemove,\n\t\tisInStub: isInStub,\n\t\tmountTo: mountTo,\n\t\tmakeVirtual: makeVirtual,\n\t\tmoveVirtual: moveVirtual,\n\t\tselectTags: selectTags\n\t});\n\t\n\t/**\n\t * Riot public api\n\t */\n\t\n\tvar settings = Object.create(brackets.settings);\n\tvar util = {\n\t  tmpl: tmpl,\n\t  brackets: brackets,\n\t  styleManager: styleManager,\n\t  vdom: __TAGS_CACHE,\n\t  styleNode: styleManager.styleNode,\n\t  // export the riot internal utils as well\n\t  dom: dom,\n\t  check: check,\n\t  misc: misc,\n\t  tags: tags\n\t};\n\t\n\texports.settings = settings;\n\texports.util = util;\n\texports.observable = observable;\n\texports.Tag = Tag$1;\n\texports.tag = tag$$1;\n\texports.tag2 = tag2$$1;\n\texports.mount = mount$$1;\n\texports.mixin = mixin$$1;\n\texports.update = update$1;\n\texports.unregister = unregister$$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tvar nargs = /\\{([0-9a-zA-Z_]+)\\}/g\n\t\n\tmodule.exports = template\n\t\n\tfunction template(string) {\n\t    var args\n\t\n\t    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\n\t        args = arguments[1]\n\t    } else {\n\t        args = new Array(arguments.length - 1)\n\t        for (var i = 1; i < arguments.length; ++i) {\n\t            args[i - 1] = arguments[i]\n\t        }\n\t    }\n\t\n\t    if (!args || !args.hasOwnProperty) {\n\t        args = {}\n\t    }\n\t\n\t    return string.replace(nargs, function replaceArg(match, i, index) {\n\t        var result\n\t\n\t        if (string[index - 1] === \"{\" &&\n\t            string[index + match.length] === \"}\") {\n\t            return i\n\t        } else {\n\t            result = args.hasOwnProperty(i) ? args[i] : null\n\t            if (result === null || result === undefined) {\n\t                return \"\"\n\t            }\n\t\n\t            return result\n\t        }\n\t    })\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('raw-html', '', '', '', function (opts) {\n\t  var _this = this;\n\t\n\t  this.updateContent = function () {\n\t    _this.root.innerHTML = _this.opts.content;\n\t  };\n\t\n\t  this.on('update', function () {\n\t    _this.updateContent();\n\t  });\n\t\n\t  this.updateContent();\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\t__webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\triot.tag2('riot-infobox', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"d3-playbooks__infobox {-empty: empty}\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.empty = true;\n\t\n\t  this.opts.control.on(riot.EVT.updateInfobox, function (data) {\n\t    _this.update({\n\t      empty: false,\n\t      rawContent: (0, _stringTemplate2.default)(_this.opts.template, data)\n\t    });\n\t  });\n\t\n\t  this.opts.control.on(riot.EVT.emptyInfobox, function () {\n\t    _this.update({ empty: true });\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\t__webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\triot.tag2('riot-legend', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"d3-playbooks__legend\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.rawContent = (0, _stringTemplate2.default)(this.opts.templates.wrapper, {\n\t    body: this.opts.legendItems.map(function (l) {\n\t      return (0, _stringTemplate2.default)(_this.opts.templates.item, l);\n\t    }).join('')\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\triot.tag2('riot-selector', '<select onchange=\"{hilight}\"> <option each=\"{label, i in labels}\" value=\"{i}\" __selected=\"{active === i}\">{label}</option> </select>', '', 'class=\"d3-playbooks__selector\"', function (opts) {\n\t  var _this = this;\n\t\n\t  this.active = 0;\n\t  this.data = this.opts.data;\n\t  this.labels = Object.keys(this.data);\n\t\n\t  this.hilight = function (e) {\n\t    var label = _this.labels[e.target.value];\n\t    var data = _this.data[label];\n\t    _this.opts.hilight(data);\n\t    _this.opts.control.trigger(riot.EVT.updateInfobox, data);\n\t  };\n\t\n\t  this.opts.control.on(riot.EVT.updateSelector, function (data) {\n\t    var active = _this.labels.indexOf(_this.opts.getLabel(data));\n\t    _this.update({ active: active });\n\t  });\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// render some base examples\n\texports.default = function () {\n\t\n\t  var chart = d3.playbooks.barChart({\n\t    elementId: 'chart1',\n\t    data: [['a', 'c', 'b'], ['1', 3, '2']]\n\t  }).render().legend({\n\t    wrapperTemplate: '<h3>Legend</h3><p>{body}</p>',\n\t    itemTemplate: 'The color for <strong>{label}</strong> is <em>{color}</em>.'\n\t  }).infobox({\n\t    element: '#my-infobox',\n\t    template: '<p><strong>Value for {x}:</strong> {y}</p>'\n\t  }).selector({\n\t    getLabel: function getLabel(d) {\n\t      return d.x + ' (' + d.y + ')';\n\t    },\n\t    sortItems: function sortItems(a, b) {\n\t      return b.y - a.y;\n\t    }\n\t  });\n\t\n\t  d3.playbooks.scatterChart({\n\t    elementId: 'chart2',\n\t    data: {\n\t      x: [1, 2, 3, 4, 6],\n\t      y: [2, 5, 1, 1, 8]\n\t    },\n\t    color: d3.schemeCategory10,\n\t    getLegendItems: function getLegendItems(C) {\n\t      return C.data.map(function (d) {\n\t        return {\n\t          label: 'Item ' + d.x,\n\t          color: C.getColor(d)\n\t        };\n\t      });\n\t    }\n\t  }).render().legend().infobox().selector();\n\t\n\t  d3.playbooks.multiLineChart({\n\t    elementId: 'chart3',\n\t    dataUrl: 'data/multiline.csv',\n\t    yCols: ['y1', 'y2', 'y3']\n\t  }).render().infobox();\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(30);\n\t\n\t__webpack_require__(12);\n\t\n\tvar _examples = __webpack_require__(7);\n\t\n\tvar _examples2 = _interopRequireDefault(_examples);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// event handling\n\t\n\t\n\t// additional stzle\n\t\n\t\n\t// exported stuff\n\tif (false) {\n\t  (0, _examples2.default)();\n\t}\n\t\n\t// dev mode\n\t// available components\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _hilight_node = __webpack_require__(17);\n\t\n\tvar _hilight_node2 = _interopRequireDefault(_hilight_node);\n\t\n\tvar _unhilight_node = __webpack_require__(19);\n\t\n\tvar _unhilight_node2 = _interopRequireDefault(_unhilight_node);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  hilightNode: _hilight_node2.default,\n\t  unhilightNode: _unhilight_node2.default\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _mount_riot_tag = __webpack_require__(24);\n\t\n\tvar _mount_riot_tag2 = _interopRequireDefault(_mount_riot_tag);\n\t\n\tvar _get_legend_items = __webpack_require__(22);\n\t\n\tvar _get_legend_items2 = _interopRequireDefault(_get_legend_items);\n\t\n\tvar _get_legend_template = __webpack_require__(23);\n\t\n\tvar _get_legend_template2 = _interopRequireDefault(_get_legend_template);\n\t\n\tvar _get_infobox_template = __webpack_require__(21);\n\t\n\tvar _get_infobox_template2 = _interopRequireDefault(_get_infobox_template);\n\t\n\tvar _get_selector_data = __webpack_require__(25);\n\t\n\tvar _get_selector_data2 = _interopRequireDefault(_get_selector_data);\n\t\n\tvar _find_selection = __webpack_require__(16);\n\t\n\tvar _find_selection2 = _interopRequireDefault(_find_selection);\n\t\n\tvar _hilight_selection = __webpack_require__(18);\n\t\n\tvar _hilight_selection2 = _interopRequireDefault(_hilight_selection);\n\t\n\tvar _unhilight_selection = __webpack_require__(20);\n\t\n\tvar _unhilight_selection2 = _interopRequireDefault(_unhilight_selection);\n\t\n\tvar _add_mouse_events = __webpack_require__(13);\n\t\n\tvar _add_mouse_events2 = _interopRequireDefault(_add_mouse_events);\n\t\n\tvar _init_riot_events = __webpack_require__(15);\n\t\n\tvar _init_riot_events2 = _interopRequireDefault(_init_riot_events);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  // event bus\n\t  getControl: function getControl() {\n\t    return riot.observable();\n\t  },\n\t  addMouseEvents: _add_mouse_events2.default,\n\t  initRiotEvents: _init_riot_events2.default,\n\t\n\t  // legend\n\t  getLegendItems: _get_legend_items2.default,\n\t  getLegendTemplates: _get_legend_template2.default,\n\t  mountLegend: function mountLegend(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-legend',\n\t      riotSelector: opts.element,\n\t      cssClass: 'legend',\n\t      opts: {\n\t        legendItems: C.legendItems,\n\t        templates: C.legendTemplates\n\t      }\n\t    });\n\t  },\n\t\n\t  // infobox\n\t  getInfoboxTemplate: _get_infobox_template2.default,\n\t  mountInfobox: function mountInfobox(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-infobox',\n\t      riotSelector: opts.element,\n\t      cssClass: 'infobox',\n\t      opts: {\n\t        control: C.control,\n\t        template: C.infoboxTemplate\n\t      }\n\t    });\n\t  },\n\t\n\t  // data selector\n\t  getSelectorData: _get_selector_data2.default,\n\t  mountSelector: function mountSelector(C, opts) {\n\t    return (0, _mount_riot_tag2.default)(C, {\n\t      tagName: 'riot-selector',\n\t      riotSelector: opts.element,\n\t      cssClass: 'selector',\n\t      opts: {\n\t        getLabel: opts.getLabel ? opts.getLabel : function (d) {\n\t          return d[C.xCol];\n\t        },\n\t        control: C.control,\n\t        data: C.selectorData,\n\t        hilight: C.hilight\n\t      }\n\t    });\n\t  },\n\t\n\t  // hilighting\n\t  findSelectionForHilight: _find_selection2.default,\n\t  hilightSelection: _hilight_selection2.default,\n\t  unhilightSelection: _unhilight_selection2.default\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  init: {\n\t    control: 'getControl',\n\t    _events: 'initRiotEvents'\n\t  },\n\t  draw: {\n\t    _events: 'addMouseEvents'\n\t  },\n\t  legend: {\n\t    legendItems: 'getLegendItems',\n\t    legendTemplates: 'getLegendTemplates',\n\t    legendEl: 'mountLegend'\n\t  },\n\t  infobox: {\n\t    infoboxTemplate: 'getInfoboxTemplate',\n\t    infoboxEl: 'mountInfobox'\n\t  },\n\t  selector: {\n\t    selectorData: 'getSelectorData',\n\t    selectorEl: 'mountSelector'\n\t  },\n\t  hilight: {\n\t    _unhilight: 'unhilightSelection',\n\t    hilightedSel: 'findSelectionForHilight',\n\t    _hilight: 'hilightSelection'\n\t  },\n\t  unhilight: {\n\t    _: 'unhilightSelection'\n\t  }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _immutable = __webpack_require__(28);\n\t\n\tvar _plays = __webpack_require__(10);\n\t\n\tvar _plays2 = _interopRequireDefault(_plays);\n\t\n\tvar _defaults = __webpack_require__(9);\n\t\n\tvar _defaults2 = _interopRequireDefault(_defaults);\n\t\n\tvar _template = __webpack_require__(11);\n\t\n\tvar _template2 = _interopRequireDefault(_template);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// update plays & defaults\n\tvar update = (0, _immutable.fromJS)(d3.playbooks.CHARTS.baseChart).mergeDeep({ plays: _plays2.default, defaults: _defaults2.default });\n\td3.playbooks.CHARTS.baseChart = update.toJS();\n\t\n\t// update playbook template\n\td3.playbooks.TEMPLATE = d3.playbooks.TEMPLATE.mergeDeep(_template2.default);\n\t\n\tvar publics = d3.playbooks.PUBLIC_METHODS.concat(['legend', 'infobox', 'selector', 'hilight', 'unhilight']);\n\td3.playbooks.PUBLIC_METHODS = publics;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (_ref) {\n\t  var drawedSelection = _ref.drawedSelection,\n\t      control = _ref.control;\n\t\n\t  drawedSelection.on('mouseover', function (data) {\n\t    control.trigger(riot.EVT.mouseover, {\n\t      node: this,\n\t      data: data\n\t    });\n\t  });\n\t  drawedSelection.on('mouseout', function (data) {\n\t    control.trigger(riot.EVT.mouseout, {\n\t      node: this,\n\t      data: data\n\t    });\n\t  });\n\t  // if (clearSvg) {\n\t  // for mobile devices: open tooltip on click,\n\t  // but only if it's possible to clear it afterwards\n\t  // (that's what the `clearSvg` flag is for)\n\t  // FIXME: this obviously crashes with the `clearSvg` click event\n\t  // drawedSelection\n\t  //   .on('touchstart', d => {\n\t  //     control.trigger(riot.EVT.hilight, d)\n\t  //   })\n\t  // }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\t// event names\n\triot.EVT = {\n\t  mouseover: 'mouseover',\n\t  mouseout: 'mouseout',\n\t  updateInfobox: 'update_infobox',\n\t  emptyInfobox: 'empty_infobox',\n\t  updateSelector: 'update_selector'\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (chart) {\n\t  chart.control.on(riot.EVT.mouseover, function (_ref) {\n\t    var node = _ref.node,\n\t        data = _ref.data;\n\t\n\t    chart.hilightedSel ? chart.unhilight(chart) : null;\n\t    chart.hilightNode(node);\n\t    chart.control.trigger(riot.EVT.updateInfobox, data);\n\t    chart.control.trigger(riot.EVT.updateSelector, data);\n\t  });\n\t\n\t  chart.control.on(riot.EVT.mouseout, function (_ref2) {\n\t    var node = _ref2.node,\n\t        data = _ref2.data;\n\t\n\t    chart.unhilightNode(node);\n\t    chart.control.trigger(riot.EVT.emptyInfobox);\n\t  });\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// find selection based on data\n\t// can act as public function, gets `C` object\n\t//\n\t// @param data str || object\n\t//  if str, data matching with `data` === `d[xCol]`\n\t//  else complete object matching (data === d)\n\t//\n\t// https://github.com/d3/d3-selection/blob/master/README.md#selection_select\n\t//\n\texports.default = function (_ref, data) {\n\t  var drawedSelection = _ref.drawedSelection,\n\t      xCol = _ref.xCol;\n\t\n\t  var match = void 0;\n\t  if (typeof data === 'string') match = function match(d) {\n\t    return data === d[xCol];\n\t  };else match = function match(d) {\n\t    return data === d;\n\t  };\n\t\n\t  return drawedSelection.select(function (d, i) {\n\t    return match(d) ? this : null;\n\t  });\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (node) {\n\t  node.classList.add('-hilight');\n\t  node.parentNode.appendChild(node);\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (_ref) {\n\t  var hilightedSel = _ref.hilightedSel;\n\t  return hilightedSel.classed('-hilight', true);\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (node) {\n\t  return node.classList.remove('-hilight');\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (_ref) {\n\t  var hilightedSel = _ref.hilightedSel;\n\t\n\t  hilightedSel ? hilightedSel.classed('-hilight', false) : null;\n\t  return null;\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _stringTemplate = __webpack_require__(2);\n\t\n\tvar _stringTemplate2 = _interopRequireDefault(_stringTemplate);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DEFAULT_TEMPLATE = '\\n  <dl class=\"d3-playbooks__infobox-table\">\\n    <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{xCol}\">{xCol}</dt>\\n    <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{xCol}\">{xVar}</dd>\\n    {yDt}\\n  </dl>\\n';\n\t\n\tvar YCOL_TEMPLATE = '\\n  <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{yCol}\">{yCol}</dt>\\n  <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{yCol}\">{yVar}</dd>\\n';\n\t\n\tvar varTmpl = function varTmpl(_var) {\n\t  return '{' + _var + '}';\n\t};\n\tvar getYColTemplate = function getYColTemplate(yCol) {\n\t  return (0, _stringTemplate2.default)(YCOL_TEMPLATE, { yCol: yCol, yVar: varTmpl(yCol) });\n\t};\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var xCol = _ref.xCol,\n\t      yCol = _ref.yCol,\n\t      yCols = _ref.yCols;\n\t  var template = _ref2.template;\n\t\n\t  return template ? template : (0, _stringTemplate2.default)(DEFAULT_TEMPLATE, {\n\t    xCol: xCol,\n\t    xVar: varTmpl(xCol),\n\t    yDt: yCols ? yCols.map(function (yCol) {\n\t      return getYColTemplate(yCol);\n\t    }).join('') : getYColTemplate(yCol)\n\t  });\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var groupCol = _ref.groupCol,\n\t      data = _ref.data,\n\t      yCol = _ref.yCol,\n\t      yCols = _ref.yCols,\n\t      multiData = _ref.multiData,\n\t      getColor = _ref.getColor;\n\t  var labels = _ref2.labels;\n\t\n\t  if (groupCol) {\n\t    var _ret = function () {\n\t      var groups = [];\n\t      var items = [];\n\t      data.map(function (d) {\n\t        var item = d[groupCol];\n\t        if (groups.indexOf(item) < 0) {\n\t          groups.push(item);\n\t          items.push({\n\t            label: item,\n\t            color: getColor(d)\n\t          });\n\t        }\n\t      });\n\t      return {\n\t        v: items\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n\t  } else if (yCols) {\n\t    var _ret2 = function () {\n\t      // FIXME ?\n\t      var yValues = multiData.yValues;\n\t\n\t      return {\n\t        v: yCols.map(function (c, i) {\n\t          return {\n\t            label: labels ? labels[c] : c,\n\t            color: getColor(yValues[i])\n\t          };\n\t        })\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret2 === \"undefined\" ? \"undefined\" : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t  } else if (yCol) {\n\t    return [{\n\t      label: labels ? labels[yCol] : yCol,\n\t      color: getColor(data)\n\t    }];\n\t  }\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tvar WRAPPER_TEMPLATE = '<ul class=\"d3-playbooks__legend-list\">{body}</ul>';\n\t\n\tvar ITEM_TEMPLATE = '<li class=\"d3-playbooks__legend-item\">\\n  <span style=\"background-color:{color};\"></span>{label}</li>';\n\t\n\texports.default = function (_ref, _ref2) {\n\t  var wrapperTemplate = _ref2.wrapperTemplate,\n\t      itemTemplate = _ref2.itemTemplate;\n\t\n\t  _objectDestructuringEmpty(_ref);\n\t\n\t  return {\n\t    wrapper: wrapperTemplate || WRAPPER_TEMPLATE,\n\t    item: itemTemplate || ITEM_TEMPLATE\n\t  };\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// agnostic function for mounting of concrete riot tags\n\t// the first argument (object) is the actual chart (`C`) object\n\texports.default = function (_ref, _ref2) {\n\t  var cssNamespace = _ref.cssNamespace,\n\t      elementId = _ref.elementId,\n\t      element = _ref.element;\n\t  var tagName = _ref2.tagName,\n\t      riotSelector = _ref2.riotSelector,\n\t      cssClass = _ref2.cssClass,\n\t      _ref2$opts = _ref2.opts,\n\t      opts = _ref2$opts === undefined ? {} : _ref2$opts;\n\t\n\t  if (!elementId && !riotSelector) {\n\t    // instead of `d3-playbooks-base`, here we need actual element ids\n\t    throw new Error('need `chart.elementId` or `element` for riot components be able to be mounted');\n\t  }\n\t\n\t  if (!riotSelector) {\n\t    riotSelector = elementId + '-' + tagName;\n\t    var css = cssNamespace + '__' + cssClass ? cssClass : tagName;\n\t    element.append('div').attr('id', riotSelector).attr('class', cssNamespace + '__' + css);\n\t    riotSelector = '#' + riotSelector;\n\t  }\n\t\n\t  return riot.mount(riotSelector, tagName, opts)[0];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t// convert data to mapping for selector, this works only for unique (ordinal) scales\n\t//\n\t// opts:\n\t//  - getLabel: function to compute label based on chart `data`, default xCol\n\t//  - sortItems: function to sort labels, BUT based on chart `data` itself not on computed labels\n\texports.default = function (_ref, _ref2) {\n\t  var data = _ref.data,\n\t      xCol = _ref.xCol;\n\t  var getLabel = _ref2.getLabel,\n\t      sortItems = _ref2.sortItems;\n\t\n\t  var _data = {};\n\t  var getKey = function getKey(d) {\n\t    return getLabel ? getLabel(d) : d[xCol];\n\t  };\n\t  var compare = function compare(a, b) {\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t  };\n\t  var _sort = sortItems ? sortItems : function (a, b) {\n\t    return compare(getKey(a), getKey(b));\n\t  };\n\t  data.sort(_sort).map(function (d) {\n\t    return _data[getKey(d)] = d;\n\t  });\n\t  return _data;\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(27)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".d3-playbooks__infobox dl{line-height:1.4;margin:0;padding:0}.d3-playbooks__infobox-label{float:none;padding:0;margin:0;font-weight:700}.d3-playbooks__infobox-value{float:none;padding:0;margin:0 0 .4em}.d3-playbooks__infobox-table{width:250px}.d3-playbooks__infobox-table dd,.d3-playbooks__infobox-table dt{float:left;width:50%}.d3-playbooks__legend-list{padding:0;margin:0}.d3-playbooks__legend-item{list-style:none}.d3-playbooks__legend-item span{width:10px;height:10px;display:inline-block}.d3-playbooks .bar,.d3-playbooks .dot{fill-opacity:.7}.d3-playbooks .bar:hover,.d3-playbooks .dot:hover{fill-opacity:1}.d3-playbooks .bar.-hilight,.d3-playbooks .dot.-hilight{fill-opacity:1;stroke:#000;stroke-width:2px}.d3-playbooks .focus circle{fill:#4682b4;r:4}.d3-playbooks .-empty{display:none}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014-2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Immutable = factory());\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    // This implements \"is array index\" which the ECMAString spec defines as:\n\t    //\n\t    //     A String property name P is an array index if and only if\n\t    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n\t    //     to 2^32−1.\n\t    //\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n\t    if (typeof index !== 'number') {\n\t      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\t      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t        return NaN;\n\t      }\n\t      index = uint32Index;\n\t    }\n\t    return index < 0 ? ensureSize(iter) + index : index;\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && (value.constructor === Object || value.constructor === undefined);\n\t  }\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t        return true;\n\t      }\n\t      if (!valueA || !valueB) {\n\t        return false;\n\t      }\n\t    }\n\t    if (typeof valueA.equals === 'function' &&\n\t        typeof valueB.equals === 'function' &&\n\t        valueA.equals(valueB)) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        if (typeof a.cacheResult === 'function') {\n\t          a.cacheResult();\n\t        }\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.includes = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step !== 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.includes = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  var imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      if (o !== o || o === Infinity) {\n\t        return 0;\n\t      }\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    if (type === 'object') {\n\t      return hashJSObj(o);\n\t    }\n\t    if (typeof o.toString === 'function') {\n\t      return hashString(o.toString());\n\t    }\n\t    throw new Error('Value type ' + type + ' cannot be hashed.');\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash;\n\t    if (usingWeakMap) {\n\t      hash = weakMap.get(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash !== undefined) {\n\t      return hash;\n\t    }\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (usingWeakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable !== undefined &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType !== undefined) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // Get references to ES5 object methods.\n\t  var isExtensible = Object.isExtensible;\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, '@', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var usingWeakMap = typeof WeakMap === 'function';\n\t  var weakMap;\n\t  if (usingWeakMap) {\n\t    weakMap = new WeakMap();\n\t  }\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) && !isOrdered(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n\t      return emptyMap().withMutations(function(map ) {\n\t        for (var i = 0; i < keyValues.length; i += 2) {\n\t          if (i + 1 >= keyValues.length) {\n\t            throw new Error('Missing value for key: ' + keyValues[i]);\n\t          }\n\t          map.set(keyValues[i], keyValues[i + 1]);\n\t        }\n\t      });\n\t    };\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.merge === 'function' ?\n\t          m.merge.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.mergeDeep === 'function' ?\n\t          m.mergeDeep.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(existing, value, key) {\n\t    return existing && existing.mergeDeep && isIterable(value) ?\n\t      existing.mergeDeep(value) :\n\t      is(existing, value) ? existing : value;\n\t  }\n\t\n\t  function deepMergerWith(merger) {\n\t    return function(existing, value, key)  {\n\t      if (existing && existing.mergeDeepWith && isIterable(value)) {\n\t        return existing.mergeDeepWith(merger, value);\n\t      }\n\t      var nextValue = merger(existing, value, key);\n\t      return is(existing, nextValue) ? existing : nextValue;\n\t    };\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value, key)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index >= 0 && index < this.size) {\n\t        index += this._origin;\n\t        var node = listNodeFor(this, index);\n\t        return node && node.array[index & MASK];\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.insert = function(index, value) {\n\t      return this.splice(index, 0, value);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t          return this;\n\t        }\n\t      }\n\t\n\t      var editable = editableVNode(this, ownerID);\n\t      editable.array.splice(sizeIndex + 1);\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index !== index) {\n\t      return list;\n\t    }\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      end = end | 0;\n\t    }\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might need creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might need creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.includes = function(value) {\n\t      return this._iter.includes(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.includes(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          var indexedIterable = isIterable(entry);\n\t          return fn(\n\t            indexedIterable ? entry.get(1) : entry[1],\n\t            indexedIterable ? entry.get(0) : entry[0],\n\t            this$0\n\t          );\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            var indexedIterable = isIterable(entry);\n\t            return iteratorValue(\n\t              type,\n\t              indexedIterable ? entry.get(0) : entry[0],\n\t              indexedIterable ? entry.get(1) : entry[1],\n\t              step\n\t            );\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.includes(key)};\n\t    flipSequence.includes = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      if (end === Infinity) {\n\t        end = originalSize;\n\t      } else {\n\t        end = end | 0;\n\t      }\n\t    }\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size and these do not resolve to NaN.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    // Note: resolvedEnd is undefined when the original sequence's length is\n\t    // unknown and this slice did not supply an end and should contain all\n\t    // elements after resolvedBegin.\n\t    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\t    var resolvedSize = resolvedEnd - resolvedBegin;\n\t    var sliceSize;\n\t    if (resolvedSize === resolvedSize) {\n\t      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    // If iterable.size is undefined, the size of the realized sliceSeq is\n\t    // unknown at this point unless the number of items to slice is 0\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize !== 0 && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ < resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var hasInitialized;\n\t\n\t      var RecordType = function Record(values) {\n\t        if (values instanceof RecordType) {\n\t          return values;\n\t        }\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        if (!hasInitialized) {\n\t          hasInitialized = true;\n\t          var keys = Object.keys(defaultValues);\n\t          setProps(RecordTypePrototype, keys);\n\t          RecordTypePrototype.size = keys.length;\n\t          RecordTypePrototype._name = name;\n\t          RecordTypePrototype._keys = keys;\n\t          RecordTypePrototype._defaultValues = defaultValues;\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var RecordType = this.constructor;\n\t      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      if (this._map && !this._map.has(k)) {\n\t        var defaultVal = this._defaultValues[k];\n\t        if (v === defaultVal) {\n\t          return this;\n\t        }\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name || 'Record';\n\t  }\n\t\n\t  function setProps(prototype, names) {\n\t    try {\n\t      names.forEach(setProp.bind(undefined, prototype));\n\t    } catch (error) {\n\t      // Object.defineProperty failed. Probably IE8.\n\t    }\n\t  }\n\t\n\t  function setProp(prototype, name) {\n\t    Object.defineProperty(prototype, name, {\n\t      get: function() {\n\t        return this.get(name);\n\t      },\n\t      set: function(value) {\n\t        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t        this.set(name, value);\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) && !isOrdered(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      index = wrapIndex(this, index);\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterate(fn);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterator(type);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    includes: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v.toString() : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findEntry: function(predicate, context, notSetValue) {\n\t      var found = notSetValue;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastEntry: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toKeyedSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.includes(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.toKeyedSeq().reverse().keyOf(searchValue);\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    }\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t  IterablePrototype.contains = IterablePrototype.includes;\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    }\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      var key = this.lastKeyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      // If index is negative, it should resolve relative to the size of the\n\t      // collection. However size may be expensive to compute if not cached, so\n\t      // only call count() if the number is in fact negative.\n\t      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var entry = this.findLastEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return Range(0, this.size);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    }\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    includes: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    }\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.includes;\n\t  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = imul(h, 0xCC9E2D51);\n\t    h = imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(26);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(29)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// d3-playbooks.riot-components.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 74437a8583232f15ebba","/* Riot v3.0.5, @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar RIOT_PREFIX = 'riot-';\nvar RIOT_TAG_IS = 'data-is';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check whether a DOM node must be considered a part of an svg document\n * @param   { String } name -\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return RE_SVG_TAGS.test(name)\n}\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION || false // avoid IE problems\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisSVGTag: isSVGTag,\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML)\n    { return el.outerHTML }\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: mkEl,\n\tgetOuterHTML: getOuterHTML,\n\tsetInnerHTML: setInnerHTML,\n\tremAttr: remAttr,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.1\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch];\n\n      recch.lastIndex = ix;\n      ix = 1;\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) { break }\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.root && ctx.root.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      if (err.riotData.tagName) {\n        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName.toLowerCase());\n      }\n      console.error(err);\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.1';\n\n  return _tmpl\n\n})();\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n\n  for (var i = 0, el; i < len; ++i) {\n    el = list[i];\n    // return false -> current item was removed by fn during the loop\n    if (fn(el, i) === false)\n      { i--; }\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return ~array.indexOf(item)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\nvar EVENTS_PREFIX_REGEX = /^on/;\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this._parent,\n    item = this._item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag._item;\n      ptag = ptag._parent;\n    } }\n\n  // override the event properties\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  if (!dom.addEventListener) {\n    dom[name] = cb;\n    return\n  }\n\n  // avoid to bind twice the same event\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\n  // cache the callback directly on the DOM node\n  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\n  if (dom._riotEvents[name])\n    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\n  dom._riotEvents[name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag } parent - parent for tag creation\n */\nfunction updateDataIs(expr, parent) {\n  var tagName = tmpl(expr.value, parent),\n    conf;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n    var delName = expr.value,\n      tags = expr.tag._parent.tags;\n\n    setAttr(expr.tag.root, RIOT_TAG_IS, tagName); // update for css\n    arrayishRemove(tags, delName, expr.tag);\n  }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  expr.tagName = tagName;\n  expr.tag.mount();\n  expr.tag.update();\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.on('unmount', function () {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag._parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  });\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  var dom = expr.dom,\n    attrName = expr.attr,\n    isToggle = /^(show|hide)$/.test(attrName),\n    // the value for the toggle must consider also the parent tag\n    value = isToggle ? tmpl(expr.expr, extend({}, this, this.parent)) : tmpl(expr.expr, this),\n    isValueAttr = attrName === 'riot-value',\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    old;\n\n  if (expr.bool)\n    { value = value ? attrName : false; }\n  else if (isUndefined(value) || value === null)\n    { value = ''; }\n\n  if (expr._riot_id) { // if it's a tag\n    if (expr.isMounted) {\n      expr.update();\n\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n\n      if (isVirtual) {\n        var frag = document.createDocumentFragment();\n        makeVirtual.call(expr, frag);\n        expr.root.parentElement.replaceChild(frag, expr.root);\n      }\n    }\n    return\n  }\n\n  old = expr.value;\n  expr.value = value;\n\n  if (expr.update) {\n    expr.update();\n    return\n  }\n\n  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n  if (old === value) { return }\n  // no change, so nothing more to do\n  if (isValueAttr && dom.value === value) { return }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n  // remove original attribute\n  if (!expr.isAttrRemoved || !value) {\n    remAttr(dom, attrName);\n    expr.isAttrRemoved = true;\n  }\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    if (attrName === 'hide') { value = !value; }\n    dom.style.display = value ? '' : 'none';\n  // field value\n  } else if (isValueAttr) {\n    dom.value = value;\n  // <img src=\"{ expr }\">\n  } else if (startsWith(attrName, RIOT_PREFIX) && attrName !== RIOT_TAG_IS) {\n    attrName = attrName.slice(RIOT_PREFIX.length);\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName])\n      { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n    if (value != null)\n      { setAttr(dom, attrName, value); }\n  } else {\n    // <select> <option selected={true}> </select>\n    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value) {\n      parent.value = dom.value;\n    } if (expr.bool) {\n      dom[attrName] = value;\n      if (!value) { return }\n    } if (value === 0 || value && typeof value !== T_OBJECT) {\n      setAttr(dom, attrName, value);\n    }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction updateAllExpressions(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, parentTag, expr) {\n    remAttr(dom, 'if');\n    this.parentTag = parentTag;\n    this.expr = expr;\n    this.stub = document.createTextNode('');\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update() {\n    var newValue = tmpl(this.expr, this.parentTag);\n\n    if (newValue && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n\n      this.expressions = [];\n      parseExpressions.apply(this.parentTag, [this.current, this.expressions, true]);\n    } else if (!newValue && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode)\n        { this.current.parentNode.removeChild(this.current); }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (newValue) { updateAllExpressions.call(this.parentTag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n    delete this.pristine;\n    delete this.parentNode;\n    delete this.stub;\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, attrName, attrValue, parent) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    this.firstRun = true;\n\n    return this\n  },\n  update: function update() {\n    var value = this.rawValue;\n    if (this.hasExp)\n      { value = tmpl(this.rawValue, this.parent); }\n\n    // if nothing changed, we're done\n    if (!this.firstRun && value === this.value) { return }\n\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.tag || this.dom;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\n    if (isBlank(value)) {\n      // if the value is blank, we remove it\n      remAttr(this.dom, this.attr);\n    } else {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n      // set the actual DOM attr\n      setAttr(this.dom, this.attr, value);\n    }\n    this.value = value;\n    this.firstRun = false;\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    delete this.dom;\n    delete this.parent;\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n * @param   { String } tagName - key used to identify the type of tag\n * @param   { Object } parent - parent tag to remove the child from\n */\nfunction unmountRedundant(items, tags, tagName, parent) {\n\n  var i = tags.length,\n    j = items.length,\n    t;\n\n  while (i > j) {\n    t = tags[--i];\n    tags.splice(i, 1);\n    t.unmount();\n    arrayishRemove(parent.tags, tagName, t, true);\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    var tag = this$1.tags[tagName];\n    if (isArray(tag))\n      { each(tag, function (t) {\n        moveChildTag.apply(t, [tagName, i]);\n      }); }\n    else\n      { moveChildTag.apply(tag, [tagName, i]); }\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each');\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = RE_SPECIAL_TAGS.test(tagName),\n    parentNode = dom.parentNode,\n    ref = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, 'if'),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, 'if'); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(ref, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      frag = createFrag(),\n      root = ref.parentNode;\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key) {\n          return !!tmpl(ifExpr, mkitem(expr, item, i, parent))\n        }\n        // in case it's not a keyed loop\n        // we test the validity of the if expression against\n        // the item and the parent\n        return !!tmpl(ifExpr, parent) || !!tmpl(ifExpr, item)\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        _mustReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos];\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos // by default we always try to reorder the DOM elements\n      ) {\n\n        var mustAppend = i === tags.length;\n\n        tag = new Tag$$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        pos = i; // handled here so no move\n      } else { tag.update(item); }\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // #closes 2040\n        if (contains(items, oldItems[i])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n        }\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item;\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent);\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags, tagName, parent);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    root.insertBefore(frag, ref);\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, 'each')) {\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, 'if')) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, RIOT_TAG_IS)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      var conf = {root: dom, parent: this$1, hasImpl: true};\n      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n      return false\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n\n  return { tree: tree, root: root }\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (~['ref', 'data-ref'].indexOf(name)) {\n      expr =  Object.create(RefExpr).init(dom, name, attr.value, this$1);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, checkSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  el.stub = true;\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$1(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$$1(name, tmpl, css, attrs, fn) {\n  if (css)\n    { styleManager.add(css, name); }\n\n  var exists = !!__TAG_IMPL[name];\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  if (exists && util.hotReloader)\n    { util.hotReloader(name); }\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$$1(selector, tagName, opts) {\n  var tags = [];\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS);\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, RIOT_TAG_IS, tagName);\n      }\n\n      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag$$1)\n        { tags.push(tag$$1); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  var elem;\n  var allTags;\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar _id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$$1((\"__unnamed_\" + (_id++)), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error('Unregistered mixin: ' + name) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n}\n\nfunction unregister$$1(name) {\n  delete __TAG_IMPL[name];\n}\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateAllExpressions.call(ctx, [attr.expr]); }\n    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$$1(impl, conf, innerHTML) {\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = conf.isAnonymous,\n    item = cleanUpData(conf.item),\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  observable(this);\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n  root.isLoop = isLoop;\n\n  defineProperty(this, '_internal', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\n  extend(this, { root: root, opts: opts }, item);\n  defineProperty(this, 'parent', parent || false);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n    if (this.isMounted) { this.trigger('update', data); }\n    updateAllExpressions.call(this, expressions);\n    if (this.isMounted) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance,\n        props = [],\n        obj;\n\n      mix = isString(mix) ? mixin$$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (key !== 'init') {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // children in loop should inherit from true parent\n    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$$1(GLOBAL_MIXIN);\n\n    if (globalMixin) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    this.trigger('before-mount');\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, false]);\n\n    this.update(item);\n\n    if (isLoop && isAnonymous) {\n      // update the root attribute for the looped elements\n      this.root = root = dom.firstChild;\n    } else {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n      if (root.stub) { root = parent.root; }\n    }\n\n    defineProperty(this, 'root', root);\n    this.isMounted = true;\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent || this.parent.isMounted) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else { this.parent.one('mount', function () {\n      this$1.trigger('mount');\n    }); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    this.trigger('before-unmount');\n\n    // clear all attributes coming from the mounted tag\n    walkAttrs(impl.attrs, function (name) {\n      if (startsWith(name, RIOT_PREFIX))\n        { name = name.slice(RIOT_PREFIX.length); }\n      remAttr(root, name);\n    });\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n        }\n      } else {\n        while (el.firstChild) { el.removeChild(el.firstChild); }\n      }\n\n      if (!mustKeepRoot) {\n        p.removeChild(el);\n      } else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS);\n      }\n    }\n\n    if (this._internal.virts) {\n      each(this._internal.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    this.trigger('unmount');\n    this.off('*');\n    this.isMounted = false;\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG_IS) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  defineProperty(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = '';\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag._internal.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$$1) { expr.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, RIOT_TAG_IS);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$$1) && !(data && typeof data.trigger === T_FUNCTION))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n */\nfunction arrayishAdd(obj, key, value, ensureArray) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else if (!isArr || isArr && !contains(dest, value)) {\n    if (isArr) { dest.push(value); }\n    else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    each(obj[key], function(item, i) {\n      if (item === value) { obj[key].splice(i, 1); }\n    });\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub)\n      { return true }\n    dom = dom.parentNode;\n  }\n  return false\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  // clear the inner html\n  root.innerHTML = '';\n\n  var conf = { root: root, opts: opts };\n  if (opts && opts.parent) { conf.parent = opts.parent; }\n\n  if (impl && root) { Tag$$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n  this._internal.tail = this.root.appendChild(tail);\n\n  el = this._internal.head;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1._internal.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target._internal.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this._internal.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1._internal.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target._internal.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + RIOT_TAG_IS + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tisInStub: isInStub,\n\tmountTo: mountTo,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\n\nvar settings = Object.create(brackets.settings);\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\nexports.settings = settings;\nexports.util = util;\nexports.observable = observable;\nexports.Tag = Tag$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$1;\nexports.unregister = unregister$$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot/riot.js\n// module id = 1\n// module chunks = 0","var nargs = /\\{([0-9a-zA-Z_]+)\\}/g\n\nmodule.exports = template\n\nfunction template(string) {\n    var args\n\n    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\n        args = arguments[1]\n    } else {\n        args = new Array(arguments.length - 1)\n        for (var i = 1; i < arguments.length; ++i) {\n            args[i - 1] = arguments[i]\n        }\n    }\n\n    if (!args || !args.hasOwnProperty) {\n        args = {}\n    }\n\n    return string.replace(nargs, function replaceArg(match, i, index) {\n        var result\n\n        if (string[index - 1] === \"{\" &&\n            string[index + match.length] === \"}\") {\n            return i\n        } else {\n            result = args.hasOwnProperty(i) ? args[i] : null\n            if (result === null || result === undefined) {\n                return \"\"\n            }\n\n            return result\n        }\n    })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/string-template/index.js\n// module id = 2\n// module chunks = 0","riot.tag2('raw-html', '', '', '', function(opts) {\n  this.updateContent = () => {\n    this.root.innerHTML = this.opts.content\n  }\n\n  this.on('update', () => {\n    this.updateContent()\n  })\n\n  this.updateContent()\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/raw_html.tag","import render from 'string-template'\n\nimport './raw_html.tag'\n\nriot.tag2('riot-infobox', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"d3-playbooks__infobox {-empty: empty}\"', function(opts) {\n\n  this.empty = true\n\n  this.opts.control.on(riot.EVT.updateInfobox, data => {\n    this.update({\n      empty: false,\n      rawContent: render(this.opts.template, data)\n    })\n  })\n\n  this.opts.control.on(riot.EVT.emptyInfobox, () => {\n    this.update({empty: true})\n  })\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/infobox.tag","import render from 'string-template'\n\nimport './raw_html.tag'\n\nriot.tag2('riot-legend', '<raw-html content=\"{rawContent}\"></raw-html>', '', 'class=\"d3-playbooks__legend\"', function(opts) {\n\n  this.rawContent = render(this.opts.templates.wrapper, {\n    body: this.opts.legendItems.map(l => render(this.opts.templates.item, l)).join('')\n  })\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/legend.tag","riot.tag2('riot-selector', '<select onchange=\"{hilight}\"> <option each=\"{label, i in labels}\" value=\"{i}\" __selected=\"{active === i}\">{label}</option> </select>', '', 'class=\"d3-playbooks__selector\"', function(opts) {\n\n  this.active = 0\n  this.data = this.opts.data\n  this.labels = Object.keys(this.data)\n\n  this.hilight = e => {\n    const label = this.labels[e.target.value]\n    const data = this.data[label]\n    this.opts.hilight(data)\n    this.opts.control.trigger(riot.EVT.updateInfobox, data)\n  }\n\n  this.opts.control.on(riot.EVT.updateSelector, data => {\n    const active = this.labels.indexOf(this.opts.getLabel(data))\n    this.update({active})\n  })\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/selector.tag","// render some base examples\nexport default () => {\n\n  const chart = d3.playbooks.barChart({\n    elementId: 'chart1',\n    data: [\n      ['a', 'c', 'b'],\n      ['1', 3, '2']\n    ],\n  }).render().legend({\n    wrapperTemplate: '<h3>Legend</h3><p>{body}</p>',\n    itemTemplate: 'The color for <strong>{label}</strong> is <em>{color}</em>.'\n  }).infobox({\n    element: '#my-infobox',\n    template: '<p><strong>Value for {x}:</strong> {y}</p>'\n  }).selector({\n    getLabel: d => d.x + ' (' + d.y + ')',\n    sortItems: (a, b) => b.y - a.y\n  })\n\n  d3.playbooks.scatterChart({\n    elementId: 'chart2',\n    data: {\n      x: [1, 2, 3, 4, 6],\n      y: [2, 5, 1, 1, 8]\n    },\n    color: d3.schemeCategory10,\n    getLegendItems: C => {\n      return C.data.map(d => {\n        return {\n          label: 'Item ' + d.x,\n          color: C.getColor(d)\n        }\n      })\n    }\n  }).render().legend().infobox().selector()\n\n  d3.playbooks.multiLineChart({\n    elementId: 'chart3',\n    dataUrl: 'data/multiline.csv',\n    yCols: ['y1', 'y2', 'y3']\n  }).render().infobox()\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/examples.js","// available components\nimport './components/legend.tag'\nimport './components/infobox.tag'\nimport './components/selector.tag'\n\n// event handling\nimport './utils/events/event_names.js'\n\n// additional stzle\nimport './styles/main.scss'\n\n// exported stuff\nimport './public.js'\n\n// dev mode\nimport renderExamples from './examples.js'\n\nif (process.env.NODE_ENV == 'development') {\n  renderExamples()\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import hilightNode from '../utils/hilight/hilight_node.js'\nimport unhilightNode from '../utils/hilight/unhilight_node.js'\n\nexport default {\n  hilightNode,\n  unhilightNode\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/defaults.js","import mountRiotTag from '../utils/mount_riot_tag.js'\nimport getLegendItems from '../utils/legend/get_legend_items.js'\nimport getLegendTemplates from '../utils/legend/get_legend_template.js'\nimport getInfoboxTemplate from '../utils/infobox/get_infobox_template.js'\nimport getSelectorData from '../utils/selector/get_selector_data.js'\nimport findSelectionForHilight from '../utils/hilight/find_selection.js'\nimport hilightSelection from '../utils/hilight/hilight_selection.js'\nimport unhilightSelection from '../utils/hilight/unhilight_selection.js'\nimport addMouseEvents from '../utils/events/add_mouse_events.js'\nimport initRiotEvents from '../utils/events/init_riot_events.js'\n\nexport default {\n  // event bus\n  getControl: () => riot.observable(),\n  addMouseEvents,\n  initRiotEvents,\n\n  // legend\n  getLegendItems,\n  getLegendTemplates,\n  mountLegend: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-legend',\n    riotSelector: opts.element,\n    cssClass: 'legend',\n    opts: {\n      legendItems: C.legendItems,\n      templates: C.legendTemplates\n    }\n  }),\n\n  // infobox\n  getInfoboxTemplate,\n  mountInfobox: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-infobox',\n    riotSelector: opts.element,\n    cssClass: 'infobox',\n    opts: {\n      control: C.control,\n      template: C.infoboxTemplate\n    }\n  }),\n\n  // data selector\n  getSelectorData,\n  mountSelector: (C, opts) => mountRiotTag(C, {\n    tagName: 'riot-selector',\n    riotSelector: opts.element,\n    cssClass: 'selector',\n    opts: {\n      getLabel: opts.getLabel ? opts.getLabel : d => d[C.xCol],\n      control: C.control,\n      data: C.selectorData,\n      hilight: C.hilight\n    }\n  }),\n\n  // hilighting\n  findSelectionForHilight,\n  hilightSelection,\n  unhilightSelection\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/plays.js","export default {\n  init: {\n    control: 'getControl',\n    _events: 'initRiotEvents'\n  },\n  draw: {\n    _events: 'addMouseEvents',\n  },\n  legend: {\n    legendItems: 'getLegendItems',\n    legendTemplates: 'getLegendTemplates',\n    legendEl: 'mountLegend'\n  },\n  infobox: {\n    infoboxTemplate: 'getInfoboxTemplate',\n    infoboxEl: 'mountInfobox'\n  },\n  selector: {\n    selectorData: 'getSelectorData',\n    selectorEl: 'mountSelector'\n  },\n  hilight: {\n    _unhilight: 'unhilightSelection',\n    hilightedSel: 'findSelectionForHilight',\n    _hilight: 'hilightSelection'\n  },\n  unhilight: {\n    _: 'unhilightSelection'\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/playbooks/template.js","import {fromJS as _} from 'immutable'\nimport plays from './playbooks/plays.js'\nimport defaults from './playbooks/defaults.js'\nimport template from './playbooks/template.js'\n\n// update plays & defaults\nconst update = _(d3.playbooks.CHARTS.baseChart).mergeDeep({plays, defaults})\nd3.playbooks.CHARTS.baseChart = update.toJS()\n\n// update playbook template\nd3.playbooks.TEMPLATE = d3.playbooks.TEMPLATE.mergeDeep(template)\n\nconst publics = d3.playbooks.PUBLIC_METHODS.concat(['legend', 'infobox', 'selector', 'hilight', 'unhilight'])\nd3.playbooks.PUBLIC_METHODS = publics\n\n\n\n// WEBPACK FOOTER //\n// ./src/public.js","export default ({\n  drawedSelection,\n  control,\n  // clearSvg\n}) => {\n  drawedSelection\n    .on('mouseover', function(data) {\n      control.trigger(riot.EVT.mouseover, {\n        node: this,\n        data\n      })\n    })\n  drawedSelection\n    .on('mouseout', function(data) {\n      control.trigger(riot.EVT.mouseout, {\n        node: this,\n        data\n      })\n    })\n  // if (clearSvg) {\n    // for mobile devices: open tooltip on click,\n    // but only if it's possible to clear it afterwards\n    // (that's what the `clearSvg` flag is for)\n    // FIXME: this obviously crashes with the `clearSvg` click event\n    // drawedSelection\n    //   .on('touchstart', d => {\n    //     control.trigger(riot.EVT.hilight, d)\n    //   })\n  // }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/add_mouse_events.js","// event names\nriot.EVT = {\n  mouseover: 'mouseover',\n  mouseout: 'mouseout',\n  updateInfobox: 'update_infobox',\n  emptyInfobox: 'empty_infobox',\n  updateSelector: 'update_selector',\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/event_names.js","export default chart => {\n  chart.control.on(riot.EVT.mouseover, ({node, data}) => {\n    chart.hilightedSel ? chart.unhilight(chart) : null\n    chart.hilightNode(node)\n    chart.control.trigger(riot.EVT.updateInfobox, data)\n    chart.control.trigger(riot.EVT.updateSelector, data)\n  })\n\n  chart.control.on(riot.EVT.mouseout, ({node, data}) => {\n    chart.unhilightNode(node)\n    chart.control.trigger(riot.EVT.emptyInfobox)\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/events/init_riot_events.js","// find selection based on data\n// can act as public function, gets `C` object\n//\n// @param data str || object\n//  if str, data matching with `data` === `d[xCol]`\n//  else complete object matching (data === d)\n//\n// https://github.com/d3/d3-selection/blob/master/README.md#selection_select\n//\nexport default ({\n  drawedSelection,\n  xCol\n}, data) => {\n  let match\n  if (typeof data === 'string') match = d => data === d[xCol]\n  else match = d => data === d\n\n  return drawedSelection.select(function(d, i) {\n    return match(d) ? this : null\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/find_selection.js","export default node => {\n  node.classList.add('-hilight')\n  node.parentNode.appendChild(node)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/hilight_node.js","export default ({hilightedSel}) => hilightedSel.classed('-hilight', true)\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/hilight_selection.js","export default node => node.classList.remove('-hilight')\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/unhilight_node.js","export default ({hilightedSel}) => {\n  hilightedSel ? hilightedSel.classed('-hilight', false) : null\n  return null\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/hilight/unhilight_selection.js","import getTemplate from 'string-template'\n\nconst DEFAULT_TEMPLATE = `\n  <dl class=\"d3-playbooks__infobox-table\">\n    <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{xCol}\">{xCol}</dt>\n    <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{xCol}\">{xVar}</dd>\n    {yDt}\n  </dl>\n`\n\nconst YCOL_TEMPLATE = `\n  <dt class=\"d3-playbooks__infobox-label d3-playbooks__infobox-label--{yCol}\">{yCol}</dt>\n  <dd class=\"d3-playbooks__infobox-value d3-playbooks__infobox-value--{yCol}\">{yVar}</dd>\n`\n\nconst varTmpl = _var => '{' + _var + '}'\nconst getYColTemplate = yCol => getTemplate(YCOL_TEMPLATE, {yCol, yVar: varTmpl(yCol)})\n\nexport default ({\n  xCol,\n  yCol,\n  yCols\n}, {template}) => {\n  return template ? template :\n    getTemplate(DEFAULT_TEMPLATE, {\n        xCol: xCol,\n        xVar: varTmpl(xCol),\n        yDt: yCols ? yCols.map(yCol => getYColTemplate(yCol)).join('') : getYColTemplate(yCol)\n    })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/infobox/get_infobox_template.js","export default ({\n  groupCol,\n  data,\n  yCol,\n  yCols,\n  multiData,\n  getColor\n}, {labels}) => {\n  if (groupCol) {\n    let groups = []\n    let items = []\n    data.map(d => {\n      let item = d[groupCol]\n      if (groups.indexOf(item) < 0) {\n        groups.push(item)\n        items.push({\n          label: item,\n          color: getColor(d)\n        })\n      }\n    })\n    return items\n  } else if (yCols) {\n    // FIXME ?\n    let {yValues} = multiData\n    return yCols.map((c, i) => {\n      return {\n        label: labels ? labels[c] : c,\n        color: getColor(yValues[i])\n      }\n    })\n  } else if (yCol) {\n    return [{\n      label: labels ? labels[yCol] : yCol,\n      color: getColor(data)\n    }]\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/legend/get_legend_items.js","const WRAPPER_TEMPLATE = '<ul class=\"d3-playbooks__legend-list\">{body}</ul>'\n\nconst ITEM_TEMPLATE = `<li class=\"d3-playbooks__legend-item\">\n  <span style=\"background-color:{color};\"></span>{label}</li>`\n\nexport default ({}, {\n  wrapperTemplate,\n  itemTemplate\n}) => {\n  return {\n    wrapper: wrapperTemplate || WRAPPER_TEMPLATE,\n    item: itemTemplate || ITEM_TEMPLATE\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/legend/get_legend_template.js","// agnostic function for mounting of concrete riot tags\n// the first argument (object) is the actual chart (`C`) object\nexport default ({\n  cssNamespace,\n  elementId,\n  element\n}, {\n  tagName,        // riot tag name identifier as exported in component's `.tag` file\n  riotSelector,   // optional dom element selector (must be present), otherwise append to `element`\n  cssClass,       // optional css name to append to `C.cssNamespace + '__'`\n  opts={}         // optional opts given to tag initialization\n}) => {\n  if (!elementId && !riotSelector) {\n    // instead of `d3-playbooks-base`, here we need actual element ids\n    throw new Error('need `chart.elementId` or `element` for riot components be able to be mounted')\n  }\n\n  if (!riotSelector) {\n    riotSelector = elementId + '-' + tagName\n    const css = cssNamespace + '__' + cssClass ? cssClass : tagName\n    element\n      .append('div')\n      .attr('id', riotSelector)\n      .attr('class', cssNamespace + '__' + css)\n    riotSelector = '#' + riotSelector\n  }\n\n  return riot.mount(riotSelector, tagName, opts)[0]\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/mount_riot_tag.js","// convert data to mapping for selector, this works only for unique (ordinal) scales\n//\n// opts:\n//  - getLabel: function to compute label based on chart `data`, default xCol\n//  - sortItems: function to sort labels, BUT based on chart `data` itself not on computed labels\nexport default ({\n  data,\n  xCol\n}, {\n  getLabel,\n  sortItems\n}) => {\n  const _data = {}\n  const getKey = d => getLabel ? getLabel(d) : d[xCol]\n  const compare = (a, b) => a < b ? -1 : a > b ? 1 : 0\n  const _sort = sortItems ? sortItems : (a, b) => compare(getKey(a), getKey(b))\n  data.sort(_sort).map(d => _data[getKey(d)] = d)\n  return _data\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/selector/get_selector_data.js","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".d3-playbooks__infobox dl{line-height:1.4;margin:0;padding:0}.d3-playbooks__infobox-label{float:none;padding:0;margin:0;font-weight:700}.d3-playbooks__infobox-value{float:none;padding:0;margin:0 0 .4em}.d3-playbooks__infobox-table{width:250px}.d3-playbooks__infobox-table dd,.d3-playbooks__infobox-table dt{float:left;width:50%}.d3-playbooks__legend-list{padding:0;margin:0}.d3-playbooks__legend-item{list-style:none}.d3-playbooks__legend-item span{width:10px;height:10px;display:inline-block}.d3-playbooks .bar,.d3-playbooks .dot{fill-opacity:.7}.d3-playbooks .bar:hover,.d3-playbooks .dot:hover{fill-opacity:1}.d3-playbooks .bar.-hilight,.d3-playbooks .dot.-hilight{fill-opacity:1;stroke:#000;stroke-width:2px}.d3-playbooks .focus circle{fill:#4682b4;r:4}.d3-playbooks .-empty{display:none}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader!./src/styles/main.scss\n// module id = 26\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 27\n// module chunks = 0","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable/dist/immutable.js\n// module id = 28\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 29\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./main.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/styles/main.scss\n// module id = 30\n// module chunks = 0"],"sourceRoot":""}